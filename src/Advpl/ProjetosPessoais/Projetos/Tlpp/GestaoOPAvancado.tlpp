/*
 * =====================================================================
 *  GESTAOPAVANCADO.TLPP
 *  Sistema Avançado de Gestão de Ordens de Produção para Protheus PCP
 *  Desenvolvido para uso corporativo, com robustez, performance e integração
 *  Autor: Sistema PCP Avançado
 *  Data: 2025-08-04
 *  Descrição: Controle completo de OPs, materiais, apontamentos, workflow e análises
 *  Versão: 1.0 - Sistema Completo: Consulta, Dashboard, Materiais, Apontamentos, Workflow, Relatórios e Integrações
 * =====================================================================
 */

@Rest
class GestaoOPAvancado {

    // =====================================================================
    // PARTE 1: CONSULTA AVANÇADA DE ORDENS DE PRODUÇÃO
    // =====================================================================
    
    /*
     * Consulta robusta de OPs com filtros avançados, paginação e validações
     * Parâmetros: op, produto, status, dataIni, dataFim, centro, recurso, prioridade
     * Retorna: lista paginada, totalizadores, logs e análises de performance
     */
    @Get("/pcp/ops/consulta")
    action consultaOPs(params)
        Local cOP, cProduto, cStatus, dDataIni, dDataFim, cCentro, cRecurso, cPrioridade
        Local nPage, nPageSize, cOrderBy, cOrderDir, aWhere, cWhere, nOffset
        Local cQuery, cCountQuery, aItens, aCount, nTotal, aEstatisticas, oLog
        Local lErro, cErro, aDados, nI
        
        // Inicialização e validação de parâmetros
        cOP         := AllTrim(Iif(!Empty(params["op"]), params["op"], ""))
        cProduto    := AllTrim(Iif(!Empty(params["produto"]), params["produto"], ""))
        cStatus     := AllTrim(Iif(!Empty(params["status"]), params["status"], ""))
        dDataIni    := Iif(!Empty(params["dataIni"]), SToD(StrTran(params["dataIni"],"-","")), SToD(""))
        dDataFim    := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"],"-","")), SToD(""))
        cCentro     := AllTrim(Iif(!Empty(params["centro"]), params["centro"], ""))
        cRecurso    := AllTrim(Iif(!Empty(params["recurso"]), params["recurso"], ""))
        cPrioridade := AllTrim(Iif(!Empty(params["prioridade"]), params["prioridade"], ""))
        nPage       := Iif(!Empty(params["page"]), Val(params["page"]), 1)
        nPageSize   := Iif(!Empty(params["pageSize"]), Val(params["pageSize"]), 30)
        cOrderBy    := Iif(!Empty(params["orderBy"]), params["orderBy"], "C2_NUM")
        cOrderDir   := Iif(!Empty(params["orderDir"]), params["orderDir"], "DESC")
        
        // Validações de negócio
        If nPageSize > 500
            Return { "sucesso" => .F., "erro" => "Limite máximo de 500 registros por página." }
        EndIf
        If !Empty(dDataIni) .And. !Empty(dDataFim) .And. dDataFim < dDataIni
            Return { "sucesso" => .F., "erro" => "Data final deve ser maior que data inicial." }
        EndIf
        
        // Construção dinâmica do WHERE
        aWhere := { "C2.D_E_L_E_T_ = ''" }
        If !Empty(cOP)
            aAdd(aWhere, "C2_NUM LIKE '%" + cOP + "%'")
        EndIf
        If !Empty(cProduto)
            aAdd(aWhere, "C2_PRODUTO LIKE '%" + cProduto + "%'")
        EndIf
        If !Empty(cStatus)
            aAdd(aWhere, "C2_TPOP = '" + cStatus + "'")
        EndIf
        If !Empty(dDataIni)
            aAdd(aWhere, "C2_EMISSAO >= '" + DToS(dDataIni) + "'")
        EndIf
        If !Empty(dDataFim)
            aAdd(aWhere, "C2_EMISSAO <= '" + DToS(dDataFim) + "'")
        EndIf
        If !Empty(cCentro)
            aAdd(aWhere, "C2_CC = '" + cCentro + "'")
        EndIf
        If !Empty(cRecurso)
            aAdd(aWhere, "C2_RECURSO = '" + cRecurso + "'")
        EndIf
        If !Empty(cPrioridade)
            aAdd(aWhere, "C2_PRIOR = '" + cPrioridade + "'")
        EndIf
        
        cWhere := ""
        If Len(aWhere) > 0
            cWhere := " WHERE " + ArrayToStr(aWhere, " AND ")
        EndIf
        
        nOffset := (nPage - 1) * nPageSize
        
        // Query principal com JOINs para dados completos
        cQuery := "SELECT C2_NUM, C2_ITEM, C2_SEQUEN, C2_PRODUTO, B1_DESC, C2_QUANT, " +;
                 "C2_QUJE, C2_PERDA, C2_EMISSAO, C2_DATPRI, C2_DATPRF, C2_TPOP, " +;
                 "C2_CC, C2_RECURSO, C2_PRIOR, C2_LOCAL, C2_OBS, " +;
                 "CASE WHEN C2_QUJE >= C2_QUANT THEN 'FINALIZADA' " +;
                 "     WHEN C2_QUJE > 0 THEN 'EM_ANDAMENTO' " +;
                 "     ELSE 'PENDENTE' END AS STATUS_CALC " +;
                 "FROM SC2010 C2 " +;
                 "LEFT JOIN SB1010 B1 ON C2_PRODUTO = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                 cWhere + " " +;
                 "ORDER BY " + cOrderBy + " " + cOrderDir + " " +;
                 "OFFSET " + AllTrim(Str(nOffset)) + " ROWS FETCH NEXT " + AllTrim(Str(nPageSize)) + " ROWS ONLY"
        
        // Query de contagem
        cCountQuery := "SELECT COUNT(*) AS TOTAL FROM SC2010 C2 " + cWhere
        
        // Inicialização de controle de erro e log
        lErro := .F.
        cErro := ""
        oLog := { "acao" => "consultaOPs", "parametros" => params, "data" => DToS(Date()), "hora" => Time() }
        aEstatisticas := {}
        
        // Execução com tratamento de erro
        Begin Sequence
            aItens := QuerySql(cQuery)
            aCount := QuerySql(cCountQuery)
            nTotal := Iif(!Empty(aCount), aCount[1]["TOTAL"], 0)
            
            // Cálculo de estatísticas adicionais
            aEstatisticas := This:calculaEstatisticasOPs(aItens)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na consulta: " + oErr:Description
            aItens := {}
            nTotal := 0
        End Sequence
        
        // Log da operação
        This:registraLogPCP("consultaOPs", "API", oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro, "dados" => {}, "total" => 0, "page" => nPage, "pageSize" => nPageSize }
        EndIf
        
        Return { "sucesso" => .T., "dados" => aItens, "total" => nTotal, "page" => nPage, "pageSize" => nPageSize, "estatisticas" => aEstatisticas }

    // =====================================================================
    // DASHBOARD EXECUTIVO DE PRODUÇÃO
    // =====================================================================
    
    /*
     * Dashboard com KPIs, gráficos e análises de produção em tempo real
     * Calcula indicadores de performance, gargalos e tendências
     */
    @Get("/pcp/dashboard")
    action dashboardProducao(params)
        Local nTotalOPs, nOPsPendentes, nOPsAndamento, nOPsFinalizadas, nOPsAtrasadas
        Local nPercentualConclusao, nMediaDiasProduzir, aGargalos, aProdutividadeCentros
        Local aPrioridadeCritica, aEvolucaoMensal, aTop10Produtos, aIndicadores
        Local cQuery, aDados, nI, dHoje, nDias, cCentro, nQtdAtrasada
        Local nPerformanceGeral, aCurvaABC, aMateriais, lErro, cErro
        
        dHoje := Date()
        nDias := Iif(!Empty(params["periodo"]), Val(params["periodo"]), 30)
        lErro := .F.
        cErro := ""
        
        Begin Sequence
            // KPI 1: Total de OPs ativas
            cQuery := "SELECT COUNT(*) AS TOTAL FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_TPOP <> 'S'"
            aDados := QuerySql(cQuery)
            nTotalOPs := Iif(!Empty(aDados), aDados[1]["TOTAL"], 0)
            
            // KPI 2: OPs por status
            cQuery := "SELECT " +;
                     "SUM(CASE WHEN C2_QUJE = 0 THEN 1 ELSE 0 END) AS PENDENTES, " +;
                     "SUM(CASE WHEN C2_QUJE > 0 AND C2_QUJE < C2_QUANT THEN 1 ELSE 0 END) AS ANDAMENTO, " +;
                     "SUM(CASE WHEN C2_QUJE >= C2_QUANT THEN 1 ELSE 0 END) AS FINALIZADAS " +;
                     "FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_TPOP <> 'S'"
            aDados := QuerySql(cQuery)
            If !Empty(aDados)
                nOPsPendentes := aDados[1]["PENDENTES"]
                nOPsAndamento := aDados[1]["ANDAMENTO"]
                nOPsFinalizadas := aDados[1]["FINALIZADAS"]
            Else
                nOPsPendentes := nOPsAndamento := nOPsFinalizadas := 0
            EndIf
            
            // KPI 3: OPs atrasadas
            cQuery := "SELECT COUNT(*) AS ATRASADAS FROM SC2010 " +;
                     "WHERE D_E_L_E_T_ = '' AND C2_TPOP <> 'S' AND C2_DATPRF < '" + DToS(dHoje) + "' AND C2_QUJE < C2_QUANT"
            aDados := QuerySql(cQuery)
            nOPsAtrasadas := Iif(!Empty(aDados), aDados[1]["ATRASADAS"], 0)
            
            // KPI 4: Percentual de conclusão geral
            nPercentualConclusao := Iif(nTotalOPs > 0, Round((nOPsFinalizadas / nTotalOPs) * 100, 2), 0)
            
            // KPI 5: Análise de gargalos por centro de custo
            cQuery := "SELECT C2_CC, COUNT(*) AS QTD_OPS, " +;
                     "AVG(DATEDIFF(day, CONVERT(date, C2_DATPRI), CONVERT(date, C2_DATPRF))) AS DIAS_MEDIO " +;
                     "FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_TPOP <> 'S' " +;
                     "GROUP BY C2_CC ORDER BY QTD_OPS DESC"
            aGargalos := QuerySql(cQuery)
            
            // KPI 6: Produtividade por centro
            cQuery := "SELECT C2_CC, SUM(C2_QUJE) AS PRODUZIDO, SUM(C2_QUANT) AS PLANEJADO " +;
                     "FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_EMISSAO >= '" + DToS(dHoje - nDias) + "' " +;
                     "GROUP BY C2_CC ORDER BY PRODUZIDO DESC"
            aProdutividadeCentros := QuerySql(cQuery)
            
            // KPI 7: OPs de prioridade crítica
            cQuery := "SELECT C2_NUM, C2_PRODUTO, B1_DESC, C2_QUANT, C2_QUJE, C2_DATPRF " +;
                     "FROM SC2010 C2 LEFT JOIN SB1010 B1 ON C2_PRODUTO = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                     "WHERE C2.D_E_L_E_T_ = '' AND C2_PRIOR = '1' AND C2_QUJE < C2_QUANT " +;
                     "ORDER BY C2_DATPRF"
            aPrioridadeCritica := QuerySql(cQuery)
            
            // KPI 8: Top 10 produtos mais produzidos
            cQuery := "SELECT TOP 10 C2_PRODUTO, B1_DESC, SUM(C2_QUJE) AS TOTAL_PRODUZIDO " +;
                     "FROM SC2010 C2 LEFT JOIN SB1010 B1 ON C2_PRODUTO = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                     "WHERE C2.D_E_L_E_T_ = '' AND C2_EMISSAO >= '" + DToS(dHoje - nDias) + "' " +;
                     "GROUP BY C2_PRODUTO, B1_DESC ORDER BY TOTAL_PRODUZIDO DESC"
            aTop10Produtos := QuerySql(cQuery)
            
            // Performance geral (OEE simplificado)
            nPerformanceGeral := This:calculaOEESimplificado()
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao gerar dashboard: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        // Montagem do retorno estruturado
        aIndicadores := {;
            "totalOPs" => nTotalOPs,;
            "pendentes" => nOPsPendentes,;
            "emAndamento" => nOPsAndamento,;
            "finalizadas" => nOPsFinalizadas,;
            "atrasadas" => nOPsAtrasadas,;
            "percentualConclusao" => nPercentualConclusao,;
            "performanceGeral" => nPerformanceGeral;
        }
        
        This:registraLogPCP("dashboardProducao", "API", { "periodo" => nDias }, .T.)
        
        Return {;
            "sucesso" => .T.,;
            "indicadores" => aIndicadores,;
            "gargalos" => aGargalos,;
            "produtividadeCentros" => aProdutividadeCentros,;
            "prioridadeCritica" => aPrioridadeCritica,;
            "top10Produtos" => aTop10Produtos,;
            "dataAtualizacao" => DToS(Date()) + " " + Time();
        }

    // =====================================================================
    // FUNÇÕES AUXILIARES DA PARTE 1
    // =====================================================================
    
    /*
     * Calcula estatísticas detalhadas das OPs consultadas
     */
    calculaEstatisticasOPs(aItens)
        Local aStats, nI, nTotalPlanejado, nTotalProduzido, nTotalPerda
        Local nOPsNovaas, nOPsVencidas, dItem
        
        nTotalPlanejado := nTotalProduzido := nTotalPerda := 0
        nOPsNovaas := nOPsVencidas := 0
        
        For nI := 1 To Len(aItens)
            nTotalPlanejado += aItens[nI]["C2_QUANT"]
            nTotalProduzido += aItens[nI]["C2_QUJE"]
            nTotalPerda += aItens[nI]["C2_PERDA"]
            
            dItem := SToD(aItens[nI]["C2_EMISSAO"])
            If dItem >= (Date() - 7)
                nOPsNovaas++
            EndIf
            
            dItem := SToD(aItens[nI]["C2_DATPRF"])
            If dItem < Date() .And. aItens[nI]["C2_QUJE"] < aItens[nI]["C2_QUANT"]
                nOPsVencidas++
            EndIf
        Next
        
        aStats := {;
            "totalPlanejado" => nTotalPlanejado,;
            "totalProduzido" => nTotalProduzido,;
            "totalPerda" => nTotalPerda,;
            "eficiencia" => Iif(nTotalPlanejado > 0, Round((nTotalProduzido/nTotalPlanejado)*100, 2), 0),;
            "opsNovas" => nOPsNovaas,;
            "opsVencidas" => nOPsVencidas;
        }
        
        Return aStats

    /*
     * Cálculo simplificado de OEE (Overall Equipment Effectiveness)
     */
    calculaOEESimplificado()
        Local cQuery, aDados, nDisponibilidade, nPerformance, nQualidade, nOEE
        
        // Simplificação: usar dados das últimas 4 semanas
        cQuery := "SELECT " +;
                 "AVG(CASE WHEN C2_QUJE >= C2_QUANT THEN 100.0 ELSE (C2_QUJE/C2_QUANT)*100.0 END) AS PERFORMANCE, " +;
                 "AVG(CASE WHEN C2_PERDA = 0 THEN 100.0 ELSE ((C2_QUJE-C2_PERDA)/C2_QUJE)*100.0 END) AS QUALIDADE " +;
                 "FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_EMISSAO >= '" + DToS(Date() - 28) + "'"
        
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nDisponibilidade := 85  // Valor padrão estimado
            nPerformance := Iif(aDados[1]["PERFORMANCE"] != Nil, aDados[1]["PERFORMANCE"], 0)
            nQualidade := Iif(aDados[1]["QUALIDADE"] != Nil, aDados[1]["QUALIDADE"], 0)
            nOEE := Round((nDisponibilidade * nPerformance * nQualidade) / 10000, 2)
        Else
            nOEE := 0
        EndIf
        
        Return nOEE

    /*
     * Registra logs específicos do módulo PCP
     */
    registraLogPCP(cAcao, cUsuario, oDetalhes, lSucesso)
        Local file, fs, all, oLog
        
        file := "./logs_pcp.json"
        all := {}
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        
        oLog := {;
            "acao" => cAcao,;
            "usuario" => cUsuario,;
            "detalhes" => oDetalhes,;
            "sucesso" => lSucesso,;
            "data" => DToS(Date()),;
            "hora" => Time(),;
            "timestamp" => FWTimeStamp(3);
        }
        
        aAdd(all, oLog)
        
        // Manter apenas os últimos 1000 logs
        If Len(all) > 1000
            aDel(all, 1)
            aSize(all, 999)
        EndIf
        
        MemoWrite(file, JsonEncode(all))
        
        Return .T.

    // =====================================================================
    // PARTE 2: CONTROLE DE MATERIAIS E APONTAMENTOS DE PRODUÇÃO
    // =====================================================================
    
    /*
     * Consulta detalhada de materiais necessários para uma OP
     * Inclui saldo disponível, reservas, empenhos e sugestões de compra
     */
    @Get("/pcp/op/:numero/materiais")
    action consultaMateriaisOP(params)
        Local cNumOP, cQuery, aMateriaisOP, aMateriais, nI, oMaterial
        Local nSaldoDisponivel, nReservado, nEmpenhado, nNecessario, cStatus
        Local aFornecedores, aSugestoes, lErro, cErro, oLog
        
        cNumOP := AllTrim(params["numero"])
        lErro := .F.
        cErro := ""
        aMateriais := {}
        aSugestoes := {}
        
        If Empty(cNumOP)
            Return { "sucesso" => .F., "erro" => "Número da OP é obrigatório." }
        EndIf
        
        oLog := { "acao" => "consultaMateriaisOP", "op" => cNumOP, "data" => DToS(Date()), "hora" => Time() }
        
        Begin Sequence
            // Busca estrutura de materiais da OP
            cQuery := "SELECT G1_COD, G1_COMP, B1_DESC, G1_QUANT, G1_PERDA, G1_REVINI, G1_REVFIM, " +;
                     "G1_INI, G1_FIM, G1_FIXVAR, G1_GROPC, G1_OPC " +;
                     "FROM SG1010 G1 " +;
                     "INNER JOIN SB1010 B1 ON G1_COMP = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                     "INNER JOIN SC2010 C2 ON G1_COD = C2_PRODUTO AND C2.D_E_L_E_T_ = '' " +;
                     "WHERE G1.D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "' " +;
                     "ORDER BY G1_TRT"
            aMateriaisOP := QuerySql(cQuery)
            
            For nI := 1 To Len(aMateriaisOP)
                // Calcula necessidade real baseada na quantidade da OP
                cQuery := "SELECT C2_QUANT, C2_QUJE FROM SC2010 WHERE D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "'"
                aDados := QuerySql(cQuery)
                nNecessario := Iif(!Empty(aDados), (aDados[1]["C2_QUANT"] - aDados[1]["C2_QUJE"]) * aMateriaisOP[nI]["G1_QUANT"], 0)
                
                // Verifica saldo disponível
                cQuery := "SELECT SUM(B2_QATU) AS SALDO FROM SB2010 " +;
                         "WHERE D_E_L_E_T_ = '' AND B2_COD = '" + aMateriaisOP[nI]["G1_COMP"] + "'"
                aDados := QuerySql(cQuery)
                nSaldoDisponivel := Iif(!Empty(aDados), aDados[1]["SALDO"], 0)
                
                // Verifica empenhos existentes
                cQuery := "SELECT SUM(D4_QUANT - D4_QTDEENT) AS EMPENHADO FROM SD4010 " +;
                         "WHERE D_E_L_E_T_ = '' AND D4_COD = '" + aMateriaisOP[nI]["G1_COMP"] + "' AND D4_OP = '" + cNumOP + "'"
                aDados := QuerySql(cQuery)
                nEmpenhado := Iif(!Empty(aDados), aDados[1]["EMPENHADO"], 0)
                
                // Define status do material
                If nSaldoDisponivel >= nNecessario
                    cStatus := "DISPONIVEL"
                ElseIf nSaldoDisponivel > 0
                    cStatus := "PARCIAL"
                Else
                    cStatus := "INDISPONIVEL"
                EndIf
                
                // Busca fornecedores preferenciais
                aFornecedores := This:buscaFornecedoresPreferenciais(aMateriaisOP[nI]["G1_COMP"])
                
                oMaterial := {;
                    "codigo" => aMateriaisOP[nI]["G1_COMP"],;
                    "descricao" => aMateriaisOP[nI]["B1_DESC"],;
                    "quantidadeNecessaria" => nNecessario,;
                    "saldoDisponivel" => nSaldoDisponivel,;
                    "quantidadeEmpenhada" => nEmpenhado,;
                    "quantidadeFaltante" => Max(0, nNecessario - nSaldoDisponivel),;
                    "status" => cStatus,;
                    "fornecedores" => aFornecedores,;
                    "perda" => aMateriaisOP[nI]["G1_PERDA"];
                }
                
                aAdd(aMateriais, oMaterial)
                
                // Gera sugestões de compra para materiais em falta
                If nSaldoDisponivel < nNecessario
                    aAdd(aSugestoes, This:geraSugestaoCompra(aMateriaisOP[nI]["G1_COMP"], nNecessario - nSaldoDisponivel, aFornecedores))
                EndIf
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao consultar materiais da OP: " + oErr:Description
        End Sequence
        
        This:registraLogPCP("consultaMateriaisOP", "API", oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return {;
            "sucesso" => .T.,;
            "op" => cNumOP,;
            "materiais" => aMateriais,;
            "totalMateriais" => Len(aMateriais),;
            "sugestoesCompra" => aSugestoes;
        }

    /*
     * Realiza apontamento de produção com validações robustas
     * Controla quantidade produzida, refugo, tempo de produção e recursos
     */
    @Post("/pcp/op/apontamento")
    action apontamentoProducao(body)
        Local cNumOP, cItem, cSequencia, nQuantidade, nRefugo, cRecurso, cOperador
        Local dDataIni, cHoraIni, dDataFim, cHoraFim, cObservacoes, nTempoSetup, nTempoProducao
        Local cQuery, aDados, nQtdPlanejada, nQtdJaProduzida, nQtdDisponivel, lOk
        Local lErro, cErro, oLog, aValidacoes, nIndice, cMsgValidacao
        
        // Extração e validação de parâmetros
        cNumOP        := AllTrim(body["numeroOP"])
        cItem         := AllTrim(body["item"])
        cSequencia    := AllTrim(body["sequencia"])
        nQuantidade   := Val(body["quantidade"])
        nRefugo       := Val(Iif(body["refugo"] != Nil, body["refugo"], "0"))
        cRecurso      := AllTrim(body["recurso"])
        cOperador     := AllTrim(body["operador"])
        dDataIni      := SToD(StrTran(body["dataInicio"], "-", ""))
        cHoraIni      := body["horaInicio"]
        dDataFim      := SToD(StrTran(body["dataFim"], "-", ""))
        cHoraFim      := body["horaFim"]
        cObservacoes  := body["observacoes"]
        nTempoSetup   := Val(Iif(body["tempoSetup"] != Nil, body["tempoSetup"], "0"))
        nTempoProducao:= Val(Iif(body["tempoProducao"] != Nil, body["tempoProducao"], "0"))
        
        lErro := .F.
        cErro := ""
        aValidacoes := {}
        
        // Validações obrigatórias
        If Empty(cNumOP)
            aAdd(aValidacoes, "Número da OP é obrigatório")
        EndIf
        If nQuantidade <= 0
            aAdd(aValidacoes, "Quantidade deve ser maior que zero")
        EndIf
        If Empty(cRecurso)
            aAdd(aValidacoes, "Recurso é obrigatório")
        EndIf
        If Empty(cOperador)
            aAdd(aValidacoes, "Operador é obrigatório")
        EndIf
        If Empty(dDataIni) .Or. Empty(dDataFim)
            aAdd(aValidacoes, "Datas de início e fim são obrigatórias")
        EndIf
        If dDataFim < dDataIni
            aAdd(aValidacoes, "Data fim deve ser maior ou igual à data início")
        EndIf
        
        If Len(aValidacoes) > 0
            cMsgValidacao := ""
            For nIndice := 1 To Len(aValidacoes)
                cMsgValidacao += aValidacoes[nIndice] + "; "
            Next
            Return { "sucesso" => .F., "erro" => "Validações: " + cMsgValidacao }
        EndIf
        
        oLog := { "acao" => "apontamentoProducao", "op" => cNumOP, "quantidade" => nQuantidade, "operador" => cOperador, "data" => DToS(Date()), "hora" => Time() }
        
        Begin Sequence
            // Verifica se a OP existe e está liberada
            cQuery := "SELECT C2_QUANT, C2_QUJE, C2_TPOP, C2_PRODUTO FROM SC2010 " +;
                     "WHERE D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "'"
            aDados := QuerySql(cQuery)
            
            If Empty(aDados)
                lErro := .T.
                cErro := "OP não encontrada: " + cNumOP
            Else
                nQtdPlanejada := aDados[1]["C2_QUANT"]
                nQtdJaProduzida := aDados[1]["C2_QUJE"]
                nQtdDisponivel := nQtdPlanejada - nQtdJaProduzida
                
                If aDados[1]["C2_TPOP"] == "S"
                    lErro := .T.
                    cErro := "OP já está encerrada"
                ElseIf nQuantidade > nQtdDisponivel
                    lErro := .T.
                    cErro := "Quantidade a produzir (" + AllTrim(Str(nQuantidade)) + ") maior que disponível (" + AllTrim(Str(nQtdDisponivel)) + ")"
                EndIf
            EndIf
            
            If !lErro
                // Verifica disponibilidade do recurso
                If !This:verificaDisponibilidadeRecurso(cRecurso, dDataIni, cHoraIni, dDataFim, cHoraFim)
                    lErro := .T.
                    cErro := "Recurso " + cRecurso + " não disponível no período informado"
                EndIf
            EndIf
            
            If !lErro
                // Atualiza quantidade produzida na OP
                cQuery := "UPDATE SC2010 SET C2_QUJE = C2_QUJE + " + AllTrim(Str(nQuantidade)) + ", " +;
                         "C2_PERDA = C2_PERDA + " + AllTrim(Str(nRefugo)) + " " +;
                         "WHERE D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "'"
                lOk := ExecSql(cQuery)
                
                If lOk
                    // Registra o apontamento detalhado
                    This:registraApontamentoDetalhado(cNumOP, cItem, cSequencia, nQuantidade, nRefugo, cRecurso, cOperador, dDataIni, cHoraIni, dDataFim, cHoraFim, cObservacoes, nTempoSetup, nTempoProducao)
                    
                    // Atualiza status do recurso
                    This:atualizaStatusRecurso(cRecurso, "OCUPADO", cNumOP)
                    
                    // Verifica se OP foi finalizada
                    If (nQtdJaProduzida + nQuantidade) >= nQtdPlanejada
                        This:finalizarOP(cNumOP)
                    EndIf
                Else
                    lErro := .T.
                    cErro := "Falha ao atualizar quantidade produzida na OP"
                EndIf
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no apontamento: " + oErr:Description
        End Sequence
        
        This:registraLogPCP("apontamentoProducao", cOperador, oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "mensagem" => "Apontamento realizado com sucesso", "novaQuantidadeProduzida" => nQtdJaProduzida + nQuantidade }

    /*
     * Controle de recursos de produção (máquinas, operadores, ferramentas)
     * Permite reserva, ocupação e liberação de recursos
     */
    @Get("/pcp/recursos/status")
    action statusRecursos(params)
        Local cTipoRecurso, dDataConsulta, aRecursos, cQuery, aDados, nI, oRecurso
        Local cStatus, cOPAtual, nPercentualUso, aHistorico, lErro, cErro
        
        cTipoRecurso := Iif(!Empty(params["tipo"]), params["tipo"], "")
        dDataConsulta := Iif(!Empty(params["data"]), SToD(StrTran(params["data"], "-", "")), Date())
        lErro := .F.
        cErro := ""
        aRecursos := {}
        
        Begin Sequence
            // Busca recursos cadastrados
            cQuery := "SELECT H1_CODIGO, H1_DESCRI, H1_TIPO, H1_CENTRO, H1_ATIVO " +;
                     "FROM SH1010 WHERE D_E_L_E_T_ = ''"
            
            If !Empty(cTipoRecurso)
                cQuery += " AND H1_TIPO = '" + cTipoRecurso + "'"
            EndIf
            
            cQuery += " ORDER BY H1_CODIGO"
            aDados := QuerySql(cQuery)
            
            For nI := 1 To Len(aDados)
                // Verifica status atual do recurso
                cStatus := This:verificaStatusRecurso(aDados[nI]["H1_CODIGO"], dDataConsulta)
                cOPAtual := This:buscaOPAtualRecurso(aDados[nI]["H1_CODIGO"])
                nPercentualUso := This:calculaPercentualUsoRecurso(aDados[nI]["H1_CODIGO"], dDataConsulta)
                aHistorico := This:buscaHistoricoRecurso(aDados[nI]["H1_CODIGO"], dDataConsulta)
                
                oRecurso := {;
                    "codigo" => aDados[nI]["H1_CODIGO"],;
                    "descricao" => aDados[nI]["H1_DESCRI"],;
                    "tipo" => aDados[nI]["H1_TIPO"],;
                    "centro" => aDados[nI]["H1_CENTRO"],;
                    "ativo" => aDados[nI]["H1_ATIVO"] == "1",;
                    "status" => cStatus,;
                    "opAtual" => cOPAtual,;
                    "percentualUso" => nPercentualUso,;
                    "historico" => aHistorico;
                }
                
                aAdd(aRecursos, oRecurso)
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao consultar recursos: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return {;
            "sucesso" => .T.,;
            "recursos" => aRecursos,;
            "totalRecursos" => Len(aRecursos),;
            "dataConsulta" => DToS(dDataConsulta);
        }

    /*
     * Empenho automático de materiais para OP
     * Valida disponibilidade e gera empenhos no SD4
     */
    @Post("/pcp/op/:numero/empenhar")
    action empenharMateriaisOP(params)
        Local cNumOP, aMateriaisOP, nI, cMaterial, nQuantidade, nSaldoDisp, lOk
        Local cQuery, aDados, aEmpenhos, aFalhas, oEmpenho, lErro, cErro, oLog
        
        cNumOP := AllTrim(params["numero"])
        lErro := .F.
        cErro := ""
        aEmpenhos := {}
        aFalhas := {}
        
        If Empty(cNumOP)
            Return { "sucesso" => .F., "erro" => "Número da OP é obrigatório." }
        EndIf
        
        oLog := { "acao" => "empenharMateriaisOP", "op" => cNumOP, "data" => DToS(Date()), "hora" => Time() }
        
        Begin Sequence
            // Busca materiais da estrutura da OP
            cQuery := "SELECT G1_COMP, G1_QUANT FROM SG1010 G1 " +;
                     "INNER JOIN SC2010 C2 ON G1_COD = C2_PRODUTO AND C2.D_E_L_E_T_ = '' " +;
                     "WHERE G1.D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "'"
            aMateriaisOP := QuerySql(cQuery)
            
            For nI := 1 To Len(aMateriaisOP)
                cMaterial := aMateriaisOP[nI]["G1_COMP"]
                nQuantidade := aMateriaisOP[nI]["G1_QUANT"]
                
                // Verifica saldo disponível
                cQuery := "SELECT SUM(B2_QATU) AS SALDO FROM SB2010 " +;
                         "WHERE D_E_L_E_T_ = '' AND B2_COD = '" + cMaterial + "'"
                aDados := QuerySql(cQuery)
                nSaldoDisp := Iif(!Empty(aDados), aDados[1]["SALDO"], 0)
                
                If nSaldoDisp >= nQuantidade
                    // Gera empenho
                    lOk := This:gerarEmpenho(cNumOP, cMaterial, nQuantidade)
                    If lOk
                        oEmpenho := { "material" => cMaterial, "quantidade" => nQuantidade, "status" => "EMPENHADO" }
                        aAdd(aEmpenhos, oEmpenho)
                    Else
                        oEmpenho := { "material" => cMaterial, "quantidade" => nQuantidade, "status" => "ERRO_EMPENHO" }
                        aAdd(aFalhas, oEmpenho)
                    EndIf
                Else
                    oEmpenho := { "material" => cMaterial, "quantidade" => nQuantidade, "saldoDisponivel" => nSaldoDisp, "status" => "SALDO_INSUFICIENTE" }
                    aAdd(aFalhas, oEmpenho)
                EndIf
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao empenhar materiais: " + oErr:Description
        End Sequence
        
        This:registraLogPCP("empenharMateriaisOP", "API", oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return {;
            "sucesso" => .T.,;
            "op" => cNumOP,;
            "empenhosRealizados" => aEmpenhos,;
            "falhasEmpenho" => aFalhas,;
            "totalEmpenhos" => Len(aEmpenhos),;
            "totalFalhas" => Len(aFalhas);
        }

    // =====================================================================
    // FUNÇÕES AUXILIARES DA PARTE 2
    // =====================================================================
    
    /*
     * Busca fornecedores preferenciais para um produto
     */
    buscaFornecedoresPreferenciais(cProduto)
        Local cQuery, aDados, aFornecedores, nI, oFornecedor
        
        aFornecedores := {}
        cQuery := "SELECT A5_FORNECE, A5_LOJA, A2_NOME, A5_CODPRF, A5_PRECO1 " +;
                 "FROM SA5010 A5 " +;
                 "INNER JOIN SA2010 A2 ON A5_FORNECE = A2_COD AND A5_LOJA = A2_LOJA AND A2.D_E_L_E_T_ = '' " +;
                 "WHERE A5.D_E_L_E_T_ = '' AND A5_PRODUTO = '" + cProduto + "' " +;
                 "ORDER BY A5_PRECO1"
        
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            oFornecedor := {;
                "codigo" => aDados[nI]["A5_FORNECE"],;
                "loja" => aDados[nI]["A5_LOJA"],;
                "nome" => aDados[nI]["A2_NOME"],;
                "codigoProdutoFornecedor" => aDados[nI]["A5_CODPRF"],;
                "preco" => aDados[nI]["A5_PRECO1"];
            }
            aAdd(aFornecedores, oFornecedor)
        Next
        
        Return aFornecedores

    /*
     * Gera sugestão de compra para material em falta
     */
    geraSugestaoCompra(cMaterial, nQuantidadeFaltante, aFornecedores)
        Local oSugestao, dDataSugerida, nLeadTime, cFornecedorSugerido, nPrecoSugerido
        
        dDataSugerida := Date() + 1
        nLeadTime := 5  // Lead time padrão
        cFornecedorSugerido := ""
        nPrecoSugerido := 0
        
        If Len(aFornecedores) > 0
            cFornecedorSugerido := aFornecedores[1]["codigo"] + "/" + aFornecedores[1]["loja"]
            nPrecoSugerido := aFornecedores[1]["preco"]
        EndIf
        
        oSugestao := {;
            "material" => cMaterial,;
            "quantidadeSugerida" => nQuantidadeFaltante,;
            "fornecedorSugerido" => cFornecedorSugerido,;
            "precoUnitario" => nPrecoSugerido,;
            "valorTotal" => nQuantidadeFaltante * nPrecoSugerido,;
            "dataSugerida" => DToS(dDataSugerida),;
            "leadTime" => nLeadTime;
        }
        
        Return oSugestao

    /*
     * Verifica disponibilidade do recurso em um período
     */
    verificaDisponibilidadeRecurso(cRecurso, dDataIni, cHoraIni, dDataFim, cHoraFim)
        Local cQuery, aDados, lDisponivel
        
        // Verifica se o recurso está livre no período
        cQuery := "SELECT COUNT(*) AS OCUPADO FROM APONTAMENTOS_RECURSOS " +;
                 "WHERE RECURSO = '" + cRecurso + "' " +;
                 "AND ((DATA_INI <= '" + DToS(dDataIni) + "' AND DATA_FIM >= '" + DToS(dDataIni) + "') " +;
                 "OR (DATA_INI <= '" + DToS(dDataFim) + "' AND DATA_FIM >= '" + DToS(dDataFim) + "'))"
        
        aDados := QuerySql(cQuery)
        lDisponivel := Iif(!Empty(aDados), aDados[1]["OCUPADO"] == 0, .T.)
        
        Return lDisponivel

    /*
     * Registra apontamento detalhado em arquivo JSON
     */
    registraApontamentoDetalhado(cNumOP, cItem, cSequencia, nQuantidade, nRefugo, cRecurso, cOperador, dDataIni, cHoraIni, dDataFim, cHoraFim, cObservacoes, nTempoSetup, nTempoProducao)
        Local file, fs, all, oApontamento
        
        file := "./apontamentos_producao.json"
        all := {}
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        
        oApontamento := {;
            "numeroOP" => cNumOP,;
            "item" => cItem,;
            "sequencia" => cSequencia,;
            "quantidade" => nQuantidade,;
            "refugo" => nRefugo,;
            "recurso" => cRecurso,;
            "operador" => cOperador,;
            "dataInicio" => DToS(dDataIni),;
            "horaInicio" => cHoraIni,;
            "dataFim" => DToS(dDataFim),;
            "horaFim" => cHoraFim,;
            "observacoes" => cObservacoes,;
            "tempoSetup" => nTempoSetup,;
            "tempoProducao" => nTempoProducao,;
            "timestamp" => FWTimeStamp(3);
        }
        
        aAdd(all, oApontamento)
        MemoWrite(file, JsonEncode(all))
        
        Return .T.

    /*
     * Atualiza status do recurso
     */
    atualizaStatusRecurso(cRecurso, cStatus, cOP)
        Local file, fs, all, oStatus, nI, lAchou
        
        file := "./status_recursos.json"
        all := {}
        lAchou := .F.
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        
        // Procura se já existe status para o recurso
        For nI := 1 To Len(all)
            If all[nI]["recurso"] == cRecurso
                all[nI]["status"] := cStatus
                all[nI]["op"] := cOP
                all[nI]["dataAtualizacao"] := DToS(Date())
                all[nI]["horaAtualizacao"] := Time()
                lAchou := .T.
                Exit
            EndIf
        Next
        
        // Se não encontrou, adiciona novo
        If !lAchou
            oStatus := {;
                "recurso" => cRecurso,;
                "status" => cStatus,;
                "op" => cOP,;
                "dataAtualizacao" => DToS(Date()),;
                "horaAtualizacao" => Time();
            }
            aAdd(all, oStatus)
        EndIf
        
        MemoWrite(file, JsonEncode(all))
        Return .T.

    /*
     * Finaliza OP automaticamente
     */
    finalizarOP(cNumOP)
        Local cQuery, lOk
        
        cQuery := "UPDATE SC2010 SET C2_TPOP = 'S', C2_DATRF = '" + DToS(Date()) + "' " +;
                 "WHERE D_E_L_E_T_ = '' AND C2_NUM = '" + cNumOP + "'"
        
        lOk := ExecSql(cQuery)
        
        If lOk
            // Libera recursos da OP
            This:liberarRecursosOP(cNumOP)
            
            // Registra log de finalização
            This:registraLogPCP("finalizarOP", "SISTEMA", { "op" => cNumOP }, .T.)
        EndIf
        
        Return lOk

    /*
     * Verifica status atual do recurso
     */
    verificaStatusRecurso(cRecurso, dData)
        Local file, fs, all, nI, cStatus
        
        file := "./status_recursos.json"
        cStatus := "LIVRE"
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
            
            For nI := 1 To Len(all)
                If all[nI]["recurso"] == cRecurso
                    cStatus := all[nI]["status"]
                    Exit
                EndIf
            Next
        EndIf
        
        Return cStatus

    /*
     * Busca OP atual do recurso
     */
    buscaOPAtualRecurso(cRecurso)
        Local file, fs, all, nI, cOP
        
        file := "./status_recursos.json"
        cOP := ""
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
            
            For nI := 1 To Len(all)
                If all[nI]["recurso"] == cRecurso
                    cOP := all[nI]["op"]
                    Exit
                EndIf
            Next
        EndIf
        
        Return cOP

    /*
     * Calcula percentual de uso do recurso
     */
    calculaPercentualUsoRecurso(cRecurso, dData)
        Local file, fs, all, nI, nTotalHoras, nHorasUsadas, nPercentual
        
        file := "./apontamentos_producao.json"
        nTotalHoras := 8  // 8 horas padrão por dia
        nHorasUsadas := 0
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
            
            For nI := 1 To Len(all)
                If all[nI]["recurso"] == cRecurso .And. all[nI]["dataInicio"] == DToS(dData)
                    nHorasUsadas += all[nI]["tempoProducao"] / 60  // Converte minutos para horas
                EndIf
            Next
        EndIf
        
        nPercentual := Iif(nTotalHoras > 0, Round((nHorasUsadas / nTotalHoras) * 100, 2), 0)
        
        Return nPercentual

    /*
     * Busca histórico do recurso
     */
    buscaHistoricoRecurso(cRecurso, dData)
        Local file, fs, all, nI, aHistorico, oItem
        
        file := "./apontamentos_producao.json"
        aHistorico := {}
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
            
            For nI := 1 To Len(all)
                If all[nI]["recurso"] == cRecurso .And. all[nI]["dataInicio"] == DToS(dData)
                    oItem := {;
                        "op" => all[nI]["numeroOP"],;
                        "quantidade" => all[nI]["quantidade"],;
                        "operador" => all[nI]["operador"],;
                        "horaInicio" => all[nI]["horaInicio"],;
                        "horaFim" => all[nI]["horaFim"];
                    }
                    aAdd(aHistorico, oItem)
                EndIf
            Next
        EndIf
        
        Return aHistorico

    /*
     * Gera empenho de material
     */
    gerarEmpenho(cOP, cMaterial, nQuantidade)
        Local cQuery, lOk
        
        // Simulação de geração de empenho - em ambiente real usaria ExecAuto
        cQuery := "INSERT INTO SD4010 (D4_FILIAL, D4_OP, D4_COD, D4_QUANT, D4_DATA) " +;
                 "VALUES ('01', '" + cOP + "', '" + cMaterial + "', " + AllTrim(Str(nQuantidade)) + ", '" + DToS(Date()) + "')"
        
        lOk := ExecSql(cQuery)
        
        Return lOk

    /*
     * Libera recursos da OP
     */
    liberarRecursosOP(cOP)
        Local file, fs, all, nI
        
        file := "./status_recursos.json"
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
            
            For nI := 1 To Len(all)
                If all[nI]["op"] == cOP
                    all[nI]["status"] := "LIVRE"
                    all[nI]["op"] := ""
                    all[nI]["dataAtualizacao"] := DToS(Date())
                    all[nI]["horaAtualizacao"] := Time()
                EndIf
            Next
            
            MemoWrite(file, JsonEncode(all))
        EndIf
        
        Return .T.

    // =====================================================================
    // PARTE 3: WORKFLOW E APROVAÇÕES
    // =====================================================================
    
    /*
     * Solicita aprovação para criação de nova OP
     * Workflow completo com validações, níveis hierárquicos e notificações
     */
    @Post("/pcp/op/solicitar-aprovacao")
    action solicitarAprovacaoOP(body)
        Local cProduto, nQuantidade, dDataNecessidade, cPrioridade, cCentro, cSolicitante
        Local cJustificativa, cObservacoes, aValidacoes, cMsgValidacao, nIndice
        Local oSolicitacao, file, fs, all, lErro, cErro, oLog, cCodigoSolicitacao
        
        // Extração de parâmetros
        cProduto := AllTrim(body["produto"])
        nQuantidade := Val(body["quantidade"])
        dDataNecessidade := SToD(StrTran(body["dataNecessidade"], "-", ""))
        cPrioridade := AllTrim(body["prioridade"])
        cCentro := AllTrim(body["centro"])
        cSolicitante := AllTrim(body["solicitante"])
        cJustificativa := body["justificativa"]
        cObservacoes := body["observacoes"]
        
        lErro := .F.
        cErro := ""
        aValidacoes := {}
        
        // Validações obrigatórias
        If Empty(cProduto)
            aAdd(aValidacoes, "Produto é obrigatório")
        EndIf
        If nQuantidade <= 0
            aAdd(aValidacoes, "Quantidade deve ser maior que zero")
        EndIf
        If Empty(dDataNecessidade)
            aAdd(aValidacoes, "Data de necessidade é obrigatória")
        EndIf
        If dDataNecessidade < Date()
            aAdd(aValidacoes, "Data de necessidade não pode ser anterior à data atual")
        EndIf
        If Empty(cPrioridade)
            aAdd(aValidacoes, "Prioridade é obrigatória")
        EndIf
        If Empty(cSolicitante)
            aAdd(aValidacoes, "Solicitante é obrigatório")
        EndIf
        If Empty(cJustificativa)
            aAdd(aValidacoes, "Justificativa é obrigatória")
        EndIf
        
        If Len(aValidacoes) > 0
            cMsgValidacao := ""
            For nIndice := 1 To Len(aValidacoes)
                cMsgValidacao += aValidacoes[nIndice] + "; "
            Next
            Return { "sucesso" => .F., "erro" => "Validações: " + cMsgValidacao }
        EndIf
        
        Begin Sequence
            // Gera código único da solicitação
            cCodigoSolicitacao := "SOL" + DToS(Date()) + StrTran(Time(), ":", "") + StrZero(Randomize(1, 999), 3)
            
            // Validações de negócio específicas
            If !This:validaProdutoExiste(cProduto)
                lErro := .T.
                cErro := "Produto não encontrado no cadastro: " + cProduto
            EndIf
            
            If !lErro .And. !This:validaCentroExiste(cCentro)
                lErro := .T.
                cErro := "Centro de custo não encontrado: " + cCentro
            EndIf
            
            If !lErro
                // Monta objeto da solicitação
                oSolicitacao := {;
                    "codigo" => cCodigoSolicitacao,;
                    "produto" => cProduto,;
                    "quantidade" => nQuantidade,;
                    "dataNecessidade" => DToS(dDataNecessidade),;
                    "prioridade" => cPrioridade,;
                    "centro" => cCentro,;
                    "solicitante" => cSolicitante,;
                    "justificativa" => cJustificativa,;
                    "observacoes" => cObservacoes,;
                    "status" => "PENDENTE",;
                    "nivelAprovacao" => 1,;
                    "dataSolicitacao" => DToS(Date()),;
                    "horaSolicitacao" => Time(),;
                    "aprovadores" => This:defineAprovadores(cPrioridade, nQuantidade),;
                    "historico" => {};
                }
                
                // Salva solicitação
                file := "./solicitacoes_op.json"
                all := {}
                If File(file)
                    fs := MemoRead(file)
                    all := JsonDecode(fs)
                EndIf
                
                aAdd(all, oSolicitacao)
                MemoWrite(file, JsonEncode(all))
                
                // Envia notificação para aprovadores
                This:enviarNotificacaoAprovacao(oSolicitacao)
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao solicitar aprovação: " + oErr:Description
        End Sequence
        
        oLog := { "acao" => "solicitarAprovacaoOP", "codigo" => cCodigoSolicitacao, "solicitante" => cSolicitante }
        This:registraLogPCP("solicitarAprovacaoOP", cSolicitante, oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "codigoSolicitacao" => cCodigoSolicitacao, "mensagem" => "Solicitação enviada para aprovação" }

    /*
     * Processa aprovação ou rejeição de solicitação de OP
     */
    @Post("/pcp/op/aprovar")
    action processarAprovacao(body)
        Local cCodigoSolicitacao, cAprovador, cAcao, cObservacoes, file, fs, all
        Local nI, lAchou, oSolicitacao, oHistorico, lAprovado, lErro, cErro, oLog
        
        cCodigoSolicitacao := AllTrim(body["codigo"])
        cAprovador := AllTrim(body["aprovador"])
        cAcao := AllTrim(body["acao"])  // APROVAR ou REJEITAR
        cObservacoes := body["observacoes"]
        
        lErro := .F.
        cErro := ""
        lAchou := .F.
        lAprovado := .F.
        
        If Empty(cCodigoSolicitacao) .Or. Empty(cAprovador) .Or. Empty(cAcao)
            Return { "sucesso" => .F., "erro" => "Parâmetros obrigatórios: codigo, aprovador, acao" }
        EndIf
        
        If !(cAcao $ "APROVAR|REJEITAR")
            Return { "sucesso" => .F., "erro" => "Ação deve ser APROVAR ou REJEITAR" }
        EndIf
        
        Begin Sequence
            file := "./solicitacoes_op.json"
            all := {}
            
            If File(file)
                fs := MemoRead(file)
                all := JsonDecode(fs)
            EndIf
            
            // Localiza a solicitação
            For nI := 1 To Len(all)
                If all[nI]["codigo"] == cCodigoSolicitacao
                    oSolicitacao := all[nI]
                    lAchou := .T.
                    Exit
                EndIf
            Next
            
            If !lAchou
                lErro := .T.
                cErro := "Solicitação não encontrada: " + cCodigoSolicitacao
            ElseIf oSolicitacao["status"] != "PENDENTE"
                lErro := .T.
                cErro := "Solicitação já foi processada"
            ElseIf !This:validaAprovador(cAprovador, oSolicitacao["aprovadores"], oSolicitacao["nivelAprovacao"])
                lErro := .T.
                cErro := "Usuário não autorizado para esta aprovação"
            EndIf
            
            If !lErro
                // Registra histórico da aprovação
                oHistorico := {;
                    "nivel" => oSolicitacao["nivelAprovacao"],;
                    "aprovador" => cAprovador,;
                    "acao" => cAcao,;
                    "observacoes" => cObservacoes,;
                    "data" => DToS(Date()),;
                    "hora" => Time();
                }
                
                aAdd(all[nI]["historico"], oHistorico)
                
                If cAcao == "REJEITAR"
                    all[nI]["status"] := "REJEITADA"
                    all[nI]["dataRejeicao"] := DToS(Date())
                    all[nI]["horaRejeicao"] := Time()
                Else
                    // Verifica se precisa de mais níveis de aprovação
                    If This:precisaMaisAprovacao(oSolicitacao["aprovadores"], oSolicitacao["nivelAprovacao"])
                        all[nI]["nivelAprovacao"] := oSolicitacao["nivelAprovacao"] + 1
                        all[nI]["status"] := "PENDENTE"
                        // Notifica próximo nível
                        This:enviarNotificacaoAprovacao(all[nI])
                    Else
                        all[nI]["status"] := "APROVADA"
                        all[nI]["dataAprovacao"] := DToS(Date())
                        all[nI]["horaAprovacao"] := Time()
                        lAprovado := .T.
                        
                        // Cria OP automaticamente
                        This:criarOPAutomatica(all[nI])
                    EndIf
                EndIf
                
                MemoWrite(file, JsonEncode(all))
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao processar aprovação: " + oErr:Description
        End Sequence
        
        oLog := { "acao" => "processarAprovacao", "codigo" => cCodigoSolicitacao, "aprovador" => cAprovador, "resultado" => cAcao }
        This:registraLogPCP("processarAprovacao", cAprovador, oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "mensagem" => "Aprovação processada com sucesso", "opCriada" => lAprovado }

    /*
     * Lista solicitações pendentes de aprovação por usuário
     */
    @Get("/pcp/aprovacoes/pendentes/:usuario")
    action listarAprovacoesPendentes(params)
        Local cUsuario, file, fs, all, nI, aPendentes, oItem, lErro, cErro
        
        cUsuario := AllTrim(params["usuario"])
        lErro := .F.
        cErro := ""
        aPendentes := {}
        
        If Empty(cUsuario)
            Return { "sucesso" => .F., "erro" => "Usuário é obrigatório" }
        EndIf
        
        Begin Sequence
            file := "./solicitacoes_op.json"
            
            If File(file)
                fs := MemoRead(file)
                all := JsonDecode(fs)
                
                For nI := 1 To Len(all)
                    If all[nI]["status"] == "PENDENTE" .And. This:validaAprovador(cUsuario, all[nI]["aprovadores"], all[nI]["nivelAprovacao"])
                        oItem := {;
                            "codigo" => all[nI]["codigo"],;
                            "produto" => all[nI]["produto"],;
                            "quantidade" => all[nI]["quantidade"],;
                            "dataNecessidade" => all[nI]["dataNecessidade"],;
                            "prioridade" => all[nI]["prioridade"],;
                            "solicitante" => all[nI]["solicitante"],;
                            "justificativa" => all[nI]["justificativa"],;
                            "nivelAprovacao" => all[nI]["nivelAprovacao"],;
                            "dataSolicitacao" => all[nI]["dataSolicitacao"];
                        }
                        aAdd(aPendentes, oItem)
                    EndIf
                Next
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao listar aprovações pendentes: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "pendentes" => aPendentes, "total" => Len(aPendentes) }

    // =====================================================================
    // PARTE 4: RELATÓRIOS E ANÁLISES AVANÇADAS
    // =====================================================================
    
    /*
     * Relatório gerencial de produtividade com análises estatísticas
     */
    @Post("/pcp/relatorios/produtividade")
    action relatorioProdutividade(body)
        Local dDataIni, dDataFim, cCentro, cRecurso, cFormato, aResultados, cQuery
        Local aDados, nI, oAnalise, nTotalPlanejado, nTotalProduzido, nEficiencia
        Local aEficienciaCentros, aEficienciaRecursos, aEvolucaoTemporal, lErro, cErro
        
        dDataIni := SToD(StrTran(body["dataInicio"], "-", ""))
        dDataFim := SToD(StrTran(body["dataFim"], "-", ""))
        cCentro := Iif(body["centro"] != Nil, AllTrim(body["centro"]), "")
        cRecurso := Iif(body["recurso"] != Nil, AllTrim(body["recurso"]), "")
        cFormato := Iif(body["formato"] != Nil, AllTrim(body["formato"]), "JSON")
        
        lErro := .F.
        cErro := ""
        aResultados := {}
        
        If Empty(dDataIni) .Or. Empty(dDataFim)
            Return { "sucesso" => .F., "erro" => "Período é obrigatório" }
        EndIf
        
        If dDataFim < dDataIni
            Return { "sucesso" => .F., "erro" => "Data fim deve ser maior que data início" }
        EndIf
        
        Begin Sequence
            // Análise geral de produtividade
            cQuery := "SELECT SUM(C2_QUANT) AS PLANEJADO, SUM(C2_QUJE) AS PRODUZIDO, " +;
                     "SUM(C2_PERDA) AS REFUGO, COUNT(*) AS TOTAL_OPS " +;
                     "FROM SC2010 WHERE D_E_L_E_T_ = '' " +;
                     "AND C2_EMISSAO BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "'"
            
            If !Empty(cCentro)
                cQuery += " AND C2_CC = '" + cCentro + "'"
            EndIf
            
            aDados := QuerySql(cQuery)
            If !Empty(aDados)
                nTotalPlanejado := aDados[1]["PLANEJADO"]
                nTotalProduzido := aDados[1]["PRODUZIDO"]
                nEficiencia := Iif(nTotalPlanejado > 0, Round((nTotalProduzido/nTotalPlanejado)*100, 2), 0)
                
                oAnalise := {;
                    "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim),;
                    "totalPlanejado" => nTotalPlanejado,;
                    "totalProduzido" => nTotalProduzido,;
                    "totalRefugo" => aDados[1]["REFUGO"],;
                    "totalOPs" => aDados[1]["TOTAL_OPS"],;
                    "eficienciaGeral" => nEficiencia;
                }
            Else
                oAnalise := { "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim), "semDados" => .T. }
            EndIf
            
            // Eficiência por centro de custo
            cQuery := "SELECT C2_CC, SUM(C2_QUANT) AS PLANEJADO, SUM(C2_QUJE) AS PRODUZIDO, " +;
                     "COUNT(*) AS OPS FROM SC2010 WHERE D_E_L_E_T_ = '' " +;
                     "AND C2_EMISSAO BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                     "GROUP BY C2_CC ORDER BY C2_CC"
            
            aEficienciaCentros := QuerySql(cQuery)
            For nI := 1 To Len(aEficienciaCentros)
                aEficienciaCentros[nI]["eficiencia"] := Iif(aEficienciaCentros[nI]["PLANEJADO"] > 0, ;
                    Round((aEficienciaCentros[nI]["PRODUZIDO"]/aEficienciaCentros[nI]["PLANEJADO"])*100, 2), 0)
            Next
            
            // Evolução temporal (semanal)
            aEvolucaoTemporal := This:calculaEvolucaoTemporal(dDataIni, dDataFim, cCentro)
            
            // Análise de recursos
            aEficienciaRecursos := This:analisaEficienciaRecursos(dDataIni, dDataFim, cRecurso)
            
            aResultados := {;
                "analiseGeral" => oAnalise,;
                "eficienciaCentros" => aEficienciaCentros,;
                "evolucaoTemporal" => aEvolucaoTemporal,;
                "eficienciaRecursos" => aEficienciaRecursos;
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao gerar relatório: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        // Gera arquivo se solicitado
        If cFormato == "CSV"
            This:exportarCSVProdutividade(aResultados, dDataIni, dDataFim)
        EndIf
        
        Return { "sucesso" => .T., "relatorio" => aResultados, "formato" => cFormato }

    /*
     * Análise de custos de produção e desperdícios
     */
    @Get("/pcp/analises/custos")
    action analiseCustos(params)
        Local dDataIni, dDataFim, aCustos, cQuery, aDados, nI, oCusto
        Local nCustoMaterial, nCustoMaoObra, nCustoRefugo, nCustoTotal, lErro, cErro
        
        dDataIni := Iif(!Empty(params["dataIni"]), SToD(StrTran(params["dataIni"], "-", "")), Date() - 30)
        dDataFim := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"], "-", "")), Date())
        lErro := .F.
        cErro := ""
        aCustos := {}
        
        Begin Sequence
            // Análise de custos por OP
            cQuery := "SELECT C2_NUM, C2_PRODUTO, B1_DESC, C2_QUANT, C2_QUJE, C2_PERDA, " +;
                     "SUM(D4_QUANT * B1_CUSTD) AS CUSTO_MATERIAL " +;
                     "FROM SC2010 C2 " +;
                     "LEFT JOIN SB1010 B1 ON C2_PRODUTO = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                     "LEFT JOIN SD4010 D4 ON C2_NUM = D4_OP AND D4.D_E_L_E_T_ = '' " +;
                     "LEFT JOIN SB1010 B1M ON D4_COD = B1M_COD AND B1M.D_E_L_E_T_ = '' " +;
                     "WHERE C2.D_E_L_E_T_ = '' " +;
                     "AND C2_EMISSAO BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                     "GROUP BY C2_NUM, C2_PRODUTO, B1_DESC, C2_QUANT, C2_QUJE, C2_PERDA"
            
            aDados := QuerySql(cQuery)
            
            For nI := 1 To Len(aDados)
                nCustoMaterial := Iif(aDados[nI]["CUSTO_MATERIAL"] != Nil, aDados[nI]["CUSTO_MATERIAL"], 0)
                nCustoMaoObra := This:calculaCustoMaoObra(aDados[nI]["C2_NUM"])
                nCustoRefugo := This:calculaCustoRefugo(aDados[nI]["C2_NUM"], aDados[nI]["C2_PERDA"])
                nCustoTotal := nCustoMaterial + nCustoMaoObra + nCustoRefugo
                
                oCusto := {;
                    "op" => aDados[nI]["C2_NUM"],;
                    "produto" => aDados[nI]["C2_PRODUTO"],;
                    "descricao" => aDados[nI]["B1_DESC"],;
                    "quantidadePlanejada" => aDados[nI]["C2_QUANT"],;
                    "quantidadeProduzida" => aDados[nI]["C2_QUJE"],;
                    "refugo" => aDados[nI]["C2_PERDA"],;
                    "custoMaterial" => nCustoMaterial,;
                    "custoMaoObra" => nCustoMaoObra,;
                    "custoRefugo" => nCustoRefugo,;
                    "custoTotal" => nCustoTotal,;
                    "custoUnitario" => Iif(aDados[nI]["C2_QUJE"] > 0, nCustoTotal / aDados[nI]["C2_QUJE"], 0);
                }
                
                aAdd(aCustos, oCusto)
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na análise de custos: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "analise" => aCustos, "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim) }

    // =====================================================================
    // PARTE 5: INTEGRAÇÃO E UTILITÁRIOS
    // =====================================================================
    
    /*
     * Integração com sistema de compras - gera solicitações automáticas
     */
    @Post("/pcp/integracao/compras")
    action integracaoCompras(body)
        Local aMateriaisFaltantes, nI, oMaterial, aSolicitacoes, oSolicitacao
        Local cQuery, aDados, lErro, cErro, oLog, file, fs, all
        
        aMateriaisFaltantes := body["materiais"]
        lErro := .F.
        cErro := ""
        aSolicitacoes := {}
        
        If Empty(aMateriaisFaltantes) .Or. !IsArray(aMateriaisFaltantes)
            Return { "sucesso" => .F., "erro" => "Lista de materiais é obrigatória" }
        EndIf
        
        Begin Sequence
            For nI := 1 To Len(aMateriaisFaltantes)
                oMaterial := aMateriaisFaltantes[nI]
                
                // Busca fornecedor preferencial
                cQuery := "SELECT TOP 1 A5_FORNECE, A5_LOJA, A5_PRECO1 FROM SA5010 " +;
                         "WHERE D_E_L_E_T_ = '' AND A5_PRODUTO = '" + oMaterial["codigo"] + "' " +;
                         "ORDER BY A5_PRECO1"
                
                aDados := QuerySql(cQuery)
                
                If !Empty(aDados)
                    oSolicitacao := {;
                        "produto" => oMaterial["codigo"],;
                        "quantidade" => oMaterial["quantidade"],;
                        "fornecedor" => aDados[1]["A5_FORNECE"],;
                        "loja" => aDados[1]["A5_LOJA"],;
                        "precoUnitario" => aDados[1]["A5_PRECO1"],;
                        "valorTotal" => oMaterial["quantidade"] * aDados[1]["A5_PRECO1"],;
                        "dataSolicitacao" => DToS(Date()),;
                        "urgencia" => oMaterial["urgencia"],;
                        "status" => "SOLICITADO";
                    }
                    
                    aAdd(aSolicitacoes, oSolicitacao)
                EndIf
            Next
            
            // Salva solicitações de compra
            file := "./solicitacoes_compra.json"
            all := {}
            If File(file)
                fs := MemoRead(file)
                all := JsonDecode(fs)
            EndIf
            
            For nI := 1 To Len(aSolicitacoes)
                aAdd(all, aSolicitacoes[nI])
            Next
            
            MemoWrite(file, JsonEncode(all))
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na integração com compras: " + oErr:Description
        End Sequence
        
        oLog := { "acao" => "integracaoCompras", "totalSolicitacoes" => Len(aSolicitacoes) }
        This:registraLogPCP("integracaoCompras", "SISTEMA", oLog, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "solicitacoes" => aSolicitacoes, "total" => Len(aSolicitacoes) }

    /*
     * Simulação de cenários de produção
     */
    @Post("/pcp/simulacao")
    action simulacaoProducao(body)
        Local aCenarios, nI, oCenario, aResultados, oResultado, dDataSimulacao
        Local nCapacidadeDisponivel, nDemandaTotal, nPercentualAtendimento, lViavel
        Local lErro, cErro
        
        aCenarios := body["cenarios"]
        dDataSimulacao := Iif(body["dataSimulacao"] != Nil, SToD(StrTran(body["dataSimulacao"], "-", "")), Date())
        lErro := .F.
        cErro := ""
        aResultados := {}
        
        If Empty(aCenarios) .Or. !IsArray(aCenarios)
            Return { "sucesso" => .F., "erro" => "Lista de cenários é obrigatória" }
        EndIf
        
        Begin Sequence
            For nI := 1 To Len(aCenarios)
                oCenario := aCenarios[nI]
                
                // Calcula capacidade disponível
                nCapacidadeDisponivel := This:calculaCapacidadeDisponivel(oCenario["centro"], dDataSimulacao)
                
                // Calcula demanda total
                nDemandaTotal := This:calculaDemandaTotal(oCenario["produtos"], oCenario["quantidades"])
                
                // Análise de viabilidade
                nPercentualAtendimento := Iif(nDemandaTotal > 0, Round((nCapacidadeDisponivel / nDemandaTotal) * 100, 2), 100)
                lViavel := nPercentualAtendimento >= 100
                
                oResultado := {;
                    "cenario" => oCenario["nome"],;
                    "centro" => oCenario["centro"],;
                    "dataSimulacao" => DToS(dDataSimulacao),;
                    "capacidadeDisponivel" => nCapacidadeDisponivel,;
                    "demandaTotal" => nDemandaTotal,;
                    "percentualAtendimento" => nPercentualAtendimento,;
                    "viavel" => lViavel,;
                    "recomendacoes" => This:geraRecomendacoes(lViavel, nPercentualAtendimento);
                }
                
                aAdd(aResultados, oResultado)
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na simulação: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "simulacoes" => aResultados, "dataProcessamento" => DToS(Date()) }

    /*
     * Backup e restore de configurações
     */
    @Post("/pcp/backup")
    action backupConfiguracoes(body)
        Local cTipo, aArquivos, nI, cArquivo, cConteudo, oBackup, cNomeBackup
        Local lErro, cErro
        
        cTipo := Iif(body["tipo"] != Nil, AllTrim(body["tipo"]), "COMPLETO")
        lErro := .F.
        cErro := ""
        
        aArquivos := {;
            "./logs_pcp.json",;
            "./solicitacoes_op.json",;
            "./apontamentos_producao.json",;
            "./status_recursos.json",;
            "./solicitacoes_compra.json";
        }
        
        Begin Sequence
            oBackup := {;
                "tipo" => cTipo,;
                "dataBackup" => DToS(Date()),;
                "horaBackup" => Time(),;
                "arquivos" => {};
            }
            
            For nI := 1 To Len(aArquivos)
                cArquivo := aArquivos[nI]
                If File(cArquivo)
                    cConteudo := MemoRead(cArquivo)
                    aAdd(oBackup["arquivos"], { "nome" => cArquivo, "conteudo" => cConteudo })
                EndIf
            Next
            
            cNomeBackup := "./backup_pcp_" + DToS(Date()) + "_" + StrTran(Time(), ":", "") + ".json"
            MemoWrite(cNomeBackup, JsonEncode(oBackup))
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no backup: " + oErr:Description
        End Sequence
        
        Return { "sucesso" => .T., "arquivoBackup" => cNomeBackup, "totalArquivos" => Len(oBackup["arquivos"]) }

    /*
     * Restore de configurações a partir de backup
     */
    @Post("/pcp/restore")
    action restoreConfiguracoes(body)
        Local cArquivoBackup, oBackup, fs, nI, oArquivo, lErro, cErro
        
        cArquivoBackup := AllTrim(body["arquivoBackup"])
        lErro := .F.
        cErro := ""
        
        If Empty(cArquivoBackup)
            Return { "sucesso" => .F., "erro" => "Nome do arquivo de backup é obrigatório" }
        EndIf
        
        If !File(cArquivoBackup)
            Return { "sucesso" => .F., "erro" => "Arquivo de backup não encontrado: " + cArquivoBackup }
        EndIf
        
        Begin Sequence
            fs := MemoRead(cArquivoBackup)
            oBackup := JsonDecode(fs)
            
            For nI := 1 To Len(oBackup["arquivos"])
                oArquivo := oBackup["arquivos"][nI]
                MemoWrite(oArquivo["nome"], oArquivo["conteudo"])
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no restore: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "mensagem" => "Restore executado com sucesso", "arquivosRestaurados" => Len(oBackup["arquivos"]) }

    // =====================================================================
    // MÉTODOS AUXILIARES AVANÇADOS
    // =====================================================================
    
    /*
     * Valida se produto existe no cadastro
     */
    Method validaProdutoExiste(cProduto)
        Local cQuery, aDados
        
        cQuery := "SELECT B1_COD FROM SB1010 WHERE D_E_L_E_T_ = '' AND B1_COD = '" + cProduto + "'"
        aDados := QuerySql(cQuery)
        
        Return !Empty(aDados)

    /*
     * Valida se centro de custo existe
     */
    Method validaCentroExiste(cCentro)
        Local cQuery, aDados
        
        cQuery := "SELECT CTT_CUSTO FROM CTT010 WHERE D_E_L_E_T_ = '' AND CTT_CUSTO = '" + cCentro + "'"
        aDados := QuerySql(cQuery)
        
        Return !Empty(aDados)

    /*
     * Define aprovadores baseado na prioridade e quantidade
     */
    Method defineAprovadores(cPrioridade, nQuantidade)
        Local aAprovadores, aNivel1, aNivel2, aNivel3
        
        aNivel1 := { "SUPERVISOR01", "SUPERVISOR02" }
        aNivel2 := { "GERENTE01", "GERENTE02" }  
        aNivel3 := { "DIRETOR01" }
        
        aAprovadores := { aNivel1 }
        
        If cPrioridade == "ALTA" .Or. nQuantidade > 1000
            aAdd(aAprovadores, aNivel2)
        EndIf
        
        If cPrioridade == "CRÍTICA" .Or. nQuantidade > 5000
            aAdd(aAprovadores, aNivel3)
        EndIf
        
        Return aAprovadores

    /*
     * Envia notificação para aprovadores
     */
    Method enviarNotificacaoAprovacao(oSolicitacao)
        Local aAprovadores, nNivel, aUsuarios, nI, oNotificacao, file, fs, all
        
        nNivel := oSolicitacao["nivelAprovacao"]
        aAprovadores := oSolicitacao["aprovadores"]
        
        If nNivel <= Len(aAprovadores)
            aUsuarios := aAprovadores[nNivel]
            
            file := "./notificacoes.json"
            all := {}
            If File(file)
                fs := MemoRead(file)
                all := JsonDecode(fs)
            EndIf
            
            For nI := 1 To Len(aUsuarios)
                oNotificacao := {;
                    "usuario" => aUsuarios[nI],;
                    "tipo" => "APROVACAO_OP",;
                    "codigo" => oSolicitacao["codigo"],;
                    "mensagem" => "Nova solicitação de OP aguardando aprovação",;
                    "data" => DToS(Date()),;
                    "hora" => Time(),;
                    "lida" => .F.;
                }
                
                aAdd(all, oNotificacao)
            Next
            
            MemoWrite(file, JsonEncode(all))
        EndIf
        
        Return .T.

    /*
     * Valida se usuário pode aprovar no nível atual
     */
    Method validaAprovador(cUsuario, aAprovadores, nNivel)
        Local aUsuariosNivel, nI
        
        If nNivel > Len(aAprovadores)
            Return .F.
        EndIf
        
        aUsuariosNivel := aAprovadores[nNivel]
        
        For nI := 1 To Len(aUsuariosNivel)
            If aUsuariosNivel[nI] == cUsuario
                Return .T.
            EndIf
        Next
        
        Return .F.

    /*
     * Verifica se precisa de mais níveis de aprovação
     */
    Method precisaMaisAprovacao(aAprovadores, nNivelAtual)
        Return nNivelAtual < Len(aAprovadores)

    /*
     * Cria OP automaticamente após aprovação completa
     */
    Method criarOPAutomatica(oSolicitacao)
        Local cQuery, cNumOP, lErro, cErro
        
        lErro := .F.
        cErro := ""
        
        Begin Sequence
            // Gera próximo número de OP
            cNumOP := This:geraProximoNumOP()
            
            // Insere na SC2 (simulação)
            cQuery := "INSERT INTO SC2010 (C2_FILIAL, C2_NUM, C2_PRODUTO, C2_QUANT, " +;
                     "C2_EMISSAO, C2_DATPRI, C2_CC, C2_STATUS) VALUES " +;
                     "('" + xFilial("SC2") + "', '" + cNumOP + "', '" + oSolicitacao["produto"] + "', " +;
                     oSolicitacao["quantidade"] + ", '" + DToS(Date()) + "', '" + oSolicitacao["dataNecessidade"] + "', " +;
                     "'" + oSolicitacao["centro"] + "', 'L')"
            
            // Em ambiente real, executaria: TCSqlExec(cQuery)
            // Aqui apenas registramos no log
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao criar OP: " + oErr:Description
        End Sequence
        
        Return !lErro

    /*
     * Gera próximo número de OP
     */
    Method geraProximoNumOP()
        Local cQuery, aDados, cUltimo, nProximo
        
        cQuery := "SELECT MAX(C2_NUM) AS ULTIMO FROM SC2010 WHERE D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        
        If !Empty(aDados) .And. aDados[1]["ULTIMO"] != Nil
            cUltimo := aDados[1]["ULTIMO"]
            nProximo := Val(cUltimo) + 1
        Else
            nProximo := 1
        EndIf
        
        Return StrZero(nProximo, 6)

    /*
     * Calcula evolução temporal de produtividade
     */
    Method calculaEvolucaoTemporal(dDataIni, dDataFim, cCentro)
        Local aEvolucao, dData, nSemana, cQuery, aDados, oSemana, nI
        
        aEvolucao := {}
        dData := dDataIni
        nSemana := 1
        
        While dData <= dDataFim
            cQuery := "SELECT SUM(C2_QUANT) AS PLANEJADO, SUM(C2_QUJE) AS PRODUZIDO " +;
                     "FROM SC2010 WHERE D_E_L_E_T_ = '' " +;
                     "AND C2_EMISSAO BETWEEN '" + DToS(dData) + "' AND '" + DToS(dData + 6) + "'"
            
            If !Empty(cCentro)
                cQuery += " AND C2_CC = '" + cCentro + "'"
            EndIf
            
            aDados := QuerySql(cQuery)
            
            If !Empty(aDados)
                oSemana := {;
                    "semana" => nSemana,;
                    "dataInicio" => DToS(dData),;
                    "planejado" => aDados[1]["PLANEJADO"],;
                    "produzido" => aDados[1]["PRODUZIDO"],;
                    "eficiencia" => Iif(aDados[1]["PLANEJADO"] > 0, Round((aDados[1]["PRODUZIDO"]/aDados[1]["PLANEJADO"])*100, 2), 0);
                }
                
                aAdd(aEvolucao, oSemana)
            EndIf
            
            dData += 7
            nSemana++
        EndDo
        
        Return aEvolucao

    /*
     * Analisa eficiência de recursos
     */
    Method analisaEficienciaRecursos(dDataIni, dDataFim, cRecurso)
        Local aRecursos, cQuery, aDados, nI, oRecurso
        
        cQuery := "SELECT H6_RECURSO, SUM(H6_TEMPO) AS TEMPO_USADO, " +;
                 "COUNT(*) AS APONTAMENTOS FROM SH6010 " +;
                 "WHERE D_E_L_E_T_ = '' " +;
                 "AND H6_DATAINI BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "'"
        
        If !Empty(cRecurso)
            cQuery += " AND H6_RECURSO = '" + cRecurso + "'"
        EndIf
        
        cQuery += " GROUP BY H6_RECURSO ORDER BY H6_RECURSO"
        
        aDados := QuerySql(cQuery)
        aRecursos := {}
        
        For nI := 1 To Len(aDados)
            oRecurso := {;
                "recurso" => aDados[nI]["H6_RECURSO"],;
                "tempoUsado" => aDados[nI]["TEMPO_USADO"],;
                "apontamentos" => aDados[nI]["APONTAMENTOS"],;
                "tempoDisponivel" => This:calculaTempoDisponivel(aDados[nI]["H6_RECURSO"], dDataIni, dDataFim),;
                "utilizacao" => 0;
            }
            
            If oRecurso["tempoDisponivel"] > 0
                oRecurso["utilizacao"] := Round((oRecurso["tempoUsado"] / oRecurso["tempoDisponivel"]) * 100, 2)
            EndIf
            
            aAdd(aRecursos, oRecurso)
        Next
        
        Return aRecursos

    /*
     * Calcula tempo disponível do recurso
     */
    Method calculaTempoDisponivel(cRecurso, dDataIni, dDataFim)
        Local nDias, nHorasDia, nTempoTotal
        
        nDias := dDataFim - dDataIni + 1
        nHorasDia := 8 // 8 horas por dia
        nTempoTotal := nDias * nHorasDia * 60 // em minutos
        
        Return nTempoTotal

    /*
     * Calcula custo de mão de obra por OP
     */
    Method calculaCustoMaoObra(cOP)
        Local cQuery, aDados, nCusto
        
        cQuery := "SELECT SUM(H6_TEMPO * 0.5) AS CUSTO_MO FROM SH6010 " +;
                 "WHERE D_E_L_E_T_ = '' AND H6_OP = '" + cOP + "'"
        
        aDados := QuerySql(cQuery)
        nCusto := Iif(!Empty(aDados) .And. aDados[1]["CUSTO_MO"] != Nil, aDados[1]["CUSTO_MO"], 0)
        
        Return nCusto

    /*
     * Calcula custo de refugo por OP
     */
    Method calculaCustoRefugo(cOP, nQuantRefugo)
        Local cQuery, aDados, nCustoUnitario, nCustoRefugo
        
        cQuery := "SELECT B1_CUSTD FROM SC2010 C2 " +;
                 "INNER JOIN SB1010 B1 ON C2_PRODUTO = B1_COD " +;
                 "WHERE C2.D_E_L_E_T_ = '' AND B1.D_E_L_E_T_ = '' " +;
                 "AND C2_NUM = '" + cOP + "'"
        
        aDados := QuerySql(cQuery)
        nCustoUnitario := Iif(!Empty(aDados), aDados[1]["B1_CUSTD"], 0)
        nCustoRefugo := nQuantRefugo * nCustoUnitario
        
        Return nCustoRefugo

    /*
     * Exporta relatório em formato CSV
     */
    Method exportarCSVProdutividade(aResultados, dDataIni, dDataFim)
        Local cNomeArquivo, cConteudo, nI, oItem
        
        cNomeArquivo := "./relatorio_produtividade_" + DToS(dDataIni) + "_" + DToS(dDataFim) + ".csv"
        cConteudo := "Centro;Planejado;Produzido;Eficiencia;OPs" + CRLF
        
        For nI := 1 To Len(aResultados["eficienciaCentros"])
            oItem := aResultados["eficienciaCentros"][nI]
            cConteudo += oItem["C2_CC"] + ";" + cValToChar(oItem["PLANEJADO"]) + ";" +;
                        cValToChar(oItem["PRODUZIDO"]) + ";" + cValToChar(oItem["eficiencia"]) + ";" +;
                        cValToChar(oItem["OPS"]) + CRLF
        Next
        
        MemoWrite(cNomeArquivo, cConteudo)
        
        Return cNomeArquivo

    /*
     * Calcula capacidade disponível por centro
     */
    Method calculaCapacidadeDisponivel(cCentro, dData)
        Local cQuery, aDados, nCapacidade
        
        // Simulação de cálculo de capacidade
        cQuery := "SELECT COUNT(*) * 8 * 60 AS CAPACIDADE FROM SH1010 " +;
                 "WHERE D_E_L_E_T_ = '' AND H1_CC = '" + cCentro + "'"
        
        aDados := QuerySql(cQuery)
        nCapacidade := Iif(!Empty(aDados), aDados[1]["CAPACIDADE"], 480) // 8 horas padrão
        
        Return nCapacidade

    /*
     * Calcula demanda total baseada em produtos e quantidades
     */
    Method calculaDemandaTotal(aProdutos, aQuantidades)
        Local nTotal, nI, cQuery, aDados, nTempoPadrao
        
        nTotal := 0
        
        For nI := 1 To Len(aProdutos)
            // Busca tempo padrão do produto
            cQuery := "SELECT G2_TEMPAD FROM SG2010 WHERE D_E_L_E_T_ = '' AND G2_PRODUTO = '" + aProdutos[nI] + "'"
            aDados := QuerySql(cQuery)
            nTempoPadrao := Iif(!Empty(aDados), aDados[1]["G2_TEMPAD"], 60) // 1 hora padrão
            
            nTotal += aQuantidades[nI] * nTempoPadrao
        Next
        
        Return nTotal

    /*
     * Gera recomendações baseadas na análise de viabilidade
     */
    Method geraRecomendacoes(lViavel, nPercentual)
        Local aRecomendacoes
        
        aRecomendacoes := {}
        
        If !lViavel
            If nPercentual < 50
                aAdd(aRecomendacoes, "Capacidade muito baixa - considere terceirização")
                aAdd(aRecomendacoes, "Avalie aquisição de novos equipamentos")
            ElseIf nPercentual < 80
                aAdd(aRecomendacoes, "Capacidade limitada - considere horas extras")
                aAdd(aRecomendacoes, "Reavalie prioridades de produção")
            Else
                aAdd(aRecomendacoes, "Pequeno ajuste necessário na programação")
            EndIf
        Else
            aAdd(aRecomendacoes, "Cenário viável com a capacidade atual")
            If nPercentual > 120
                aAdd(aRecomendacoes, "Capacidade ociosa - oportunidade para novos pedidos")
            EndIf
        EndIf
        
        Return aRecomendacoes

EndClass
