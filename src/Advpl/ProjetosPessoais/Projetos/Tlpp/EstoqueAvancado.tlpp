// EstoqueAvancado.tlpp
// Sistema avançado de gestão, análise e automação de estoques para Protheus
// Desenvolvido para uso corporativo, com foco em robustez, performance e integração

@Rest
class EstoqueAvancado {
    // =====================
    // CONSULTA DE ESTOQUES
    // =====================
    @Get("/estoque/consulta")
    action consultaEstoque(params) {
        // Parâmetros: produto, local, grupo, saldoMin, saldoMax, curva, page, pageSize, orderBy, orderDir
        const { produto, local, grupo, saldoMin = 0, saldoMax, curva, page = 1, pageSize = 50, orderBy = 'B2_COD', orderDir = 'ASC' } = params;
        let where = ["B2.D_E_L_E_T_ = ''"];
        if (produto) where.push(`B2_COD = '${produto}'`);
        if (local) where.push(`B2_LOCAL = '${local}'`);
        if (grupo) where.push(`B1_GRUPO = '${grupo}'`);
        if (saldoMin) where.push(`B2_QATU >= ${saldoMin}`);
        if (saldoMax) where.push(`B2_QATU <= ${saldoMax}`);
        if (curva) where.push(`B1_CURVA = '${curva}'`);
        let whereStr = where.length ? 'WHERE ' + where.join(' AND ') : '';
        let offset = (parseInt(page) - 1) * parseInt(pageSize);
        let query = `
            SELECT B2_COD, B1_DESC, B2_LOCAL, B2_QATU, B2_QRES, B2_QFUT, B1_GRUPO, B1_CURVA, B2_ULTATU
            FROM SB2
            INNER JOIN SB1 ON B2_COD = B1_COD
            ${whereStr}
            ORDER BY ${orderBy} ${orderDir}
            OFFSET ${offset} ROWS FETCH NEXT ${pageSize} ROWS ONLY
        `;
        let countQuery = `SELECT COUNT(*) as total FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD ${whereStr}`;
        try {
            const itens = QuerySql(query);
            const total = QuerySql(countQuery)[0]?.total || 0;
            this.logConsulta(params, itens.length);
            return { sucesso: true, total, page, pageSize, dados: itens };
        } catch (e) {
            this.logErro('consultaEstoque', e.message, params);
            return { sucesso: false, erro: e.message };
        }
    }

    // =====================
    // DASHBOARD DE ESTOQUE
    // =====================
    @Get("/estoque/dashboard")
    action dashboardEstoque(params)
        Local nTotal := 0, nRuptura := 0, nExcesso := 0, nGiro := 0, aCurva := {}, aLocais := {}, nDias := 90
        Local cQuery, aDados, nI
        // Total em estoque
        cQuery := "SELECT SUM(B2_QATU) AS TOTAL FROM SB2 WHERE D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nTotal := aDados[1]["TOTAL"]
        EndIf
        // Produtos em ruptura (saldo <= 0)
        cQuery := "SELECT COUNT(*) AS RUPTURA FROM SB2 WHERE D_E_L_E_T_ = '' AND B2_QATU <= 0"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nRuptura := aDados[1]["RUPTURA"]
        EndIf
        // Produtos em excesso (saldo > B1_ESTSEG*2)
        cQuery := "SELECT COUNT(*) AS EXCESSO FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD WHERE SB2.D_E_L_E_T_ = '' AND B2_QATU > B1_ESTSEG*2"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nExcesso := aDados[1]["EXCESSO"]
        EndIf
        // Giro médio dos últimos 90 dias
        cQuery := "SELECT AVG(MOV.QTDE) AS GIRO FROM (SELECT SUM(D2_QUANT) AS QTDE FROM SD2 WHERE D2_EMISSAO >= '" + DToS(Date() - nDias) + "' AND D_E_L_E_T_ = '' GROUP BY D2_COD) MOV"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nGiro := aDados[1]["GIRO"]
        EndIf
        // Curva ABC
        cQuery := "SELECT B1_CURVA, COUNT(*) AS QTD FROM SB1 WHERE D_E_L_E_T_ = '' GROUP BY B1_CURVA"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aCurva, { aDados[nI]["B1_CURVA"], aDados[nI]["QTD"] })
        Next
        // Estoque por local
        cQuery := "SELECT B2_LOCAL, SUM(B2_QATU) AS QTD FROM SB2 WHERE D_E_L_E_T_ = '' GROUP BY B2_LOCAL"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aLocais, { aDados[nI]["B2_LOCAL"], aDados[nI]["QTD"] })
        Next
        Return { "sucesso" => .T., "total" => nTotal, "ruptura" => nRuptura, "excesso" => nExcesso, "giro" => nGiro, "curva" => aCurva, "locais" => aLocais }

    // =====================
    // MOVIMENTAÇÃO DE ESTOQUE
    // =====================
    @Post("/estoque/movimentar")
    action movimentaEstoque(body)
        Local cProduto := body["produto"], cLocal := body["local"], nQtd := body["quantidade"], cTipo := body["tipo"], cObs := body["obs"]
        Local cQuery, lOk := .F.
        If Empty(cProduto) .Or. Empty(cLocal) .Or. Empty(nQtd) .Or. Empty(cTipo)
            Return { "sucesso" => .F., "erro" => "Parâmetros obrigatórios ausentes." }
        EndIf
        // Atualiza saldo
        If cTipo == "E"
            cQuery := "UPDATE SB2 SET B2_QATU = B2_QATU + " + AllTrim(Str(nQtd)) + " WHERE B2_COD = '" + cProduto + "' AND B2_LOCAL = '" + cLocal + "' AND D_E_L_E_T_ = ''"
        ElseIf cTipo == "S"
            cQuery := "UPDATE SB2 SET B2_QATU = B2_QATU - " + AllTrim(Str(nQtd)) + " WHERE B2_COD = '" + cProduto + "' AND B2_LOCAL = '" + cLocal + "' AND D_E_L_E_T_ = ''"
        Else
            Return { "sucesso" => .F., "erro" => "Tipo de movimentação inválido." }
        EndIf
        lOk := ExecSql(cQuery)
        If lOk
            // Registra histórico
            This:registraHistoricoMov(cProduto, cLocal, nQtd, cTipo, cObs)
            Return { "sucesso" => .T., "mensagem" => "Movimentação realizada com sucesso." }
        Else
            Return { "sucesso" => .F., "erro" => "Falha ao movimentar estoque." }
        EndIf

    // =====================
    // HISTÓRICO DE MOVIMENTAÇÃO
    // =====================
    @Get("/estoque/historico/:produto/:local")
    action historicoMov(params)
        Local cProduto := params["produto"], cLocal := params["local"]
        Local cQuery, aDados := {}
        If Empty(cProduto) .Or. Empty(cLocal)
            Return { "sucesso" => .F., "erro" => "Informe produto e local." }
        EndIf
        cQuery := "SELECT * FROM HISTMOV WHERE PRODUTO = '" + cProduto + "' AND LOCAL = '" + cLocal + "' ORDER BY DATA DESC"
        aDados := QuerySql(cQuery)
        Return { "sucesso" => .T., "historico" => aDados }

    // Função auxiliar: registra histórico de movimentação
    registraHistoricoMov(cProduto, cLocal, nQtd, cTipo, cObs)
        Local fs, file, all
        file := "./historico_mov.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "local" => cLocal, "quantidade" => nQtd, "tipo" => cTipo, "obs" => cObs, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    // =====================
    // RELATÓRIOS E EXPORTAÇÃO
    // =====================
    @Post("/estoque/relatorio")
    action relatorioEstoque(body)
        Local cCampos := body["campos"], cFiltro := body["filtro"], cOrder := body["order"], cFormato := body["formato"]
        Local cQuery, aDados, cFile, lOk := .F.
        If Empty(cCampos)
            cCampos := "B2_COD, B1_DESC, B2_LOCAL, B2_QATU, B1_GRUPO"
        EndIf
        cQuery := "SELECT " + cCampos + " FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD WHERE SB2.D_E_L_E_T_ = ''"
        If !Empty(cFiltro)
            cQuery += " AND " + cFiltro
        EndIf
        If !Empty(cOrder)
            cQuery += " ORDER BY " + cOrder
        EndIf
        aDados := QuerySql(cQuery)
        If cFormato == "csv"
            cFile := This:exportaCSV(aDados, cCampos)
        Else
            cFile := This:exportaXLSX(aDados, cCampos)
        EndIf
        Return { "sucesso" => .T., "arquivo" => cFile }

    exportaCSV(aDados, cCampos)
        Local cFile := "./relatorio_estoque.csv", nI, nJ, aCampos, cLinha
        aCampos := StrTokArr(cCampos, ",")
        cLinha := ""
        For nJ := 1 To Len(aCampos)
            cLinha += AllTrim(aCampos[nJ]) + ";"
        Next
        MemoWrite(cFile, cLinha + CRLF)
        For nI := 1 To Len(aDados)
            cLinha := ""
            For nJ := 1 To Len(aCampos)
                cLinha += AllTrim(Str(aDados[nI][AllTrim(aCampos[nJ])])) + ";"
            Next
            MemoWrite(cFile, MemoRead(cFile) + cLinha + CRLF)
        Next
        Return cFile

    exportaXLSX(aDados, cCampos)
        // Placeholder: exportação XLSX pode ser feita via integração externa ou rotina customizada
        Return "./relatorio_estoque.xlsx"

    // =====================
    // UPLOAD DE DOCUMENTOS
    // =====================
    @Post("/estoque/upload/:produto")
    action uploadDoc(params, req)
        Local cProduto := params["produto"], cNome := req["filename"], cConteudo := req["filedata"]
        Local cDir := "./docs_estoque/" + cProduto, cFile
        If !Directory(cDir)
            MakeDir(cDir)
        EndIf
        cFile := cDir + "/" + cNome
        MemoWrite(cFile, cConteudo)
        This:registraDocProduto(cProduto, cNome, cFile)
        Return { "sucesso" => .T., "mensagem" => "Documento salvo." }

    registraDocProduto(cProduto, cNome, cFile)
        Local fs, file, all
        file := "./docs_estoque.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "nome" => cNome, "caminho" => cFile, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    // =====================
    // COMENTÁRIOS/OCORRÊNCIAS
    // =====================
    @Post("/estoque/comentario/:produto")
    action comentaProduto(params, body)
        Local cProduto := params["produto"], cUsuario := body["usuario"], cTexto := body["comentario"]
        Local file := "./comentarios_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "usuario" => cUsuario, "comentario" => cTexto, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T. }

    @Get("/estoque/comentarios/:produto")
    action listaComentarios(params)
        Local cProduto := params["produto"], file := "./comentarios_estoque.json", fs, all, aRet := {}
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach a IN all
            If a["produto"] == cProduto
                aAdd(aRet, a)
            EndIf
        Next
        Return { "sucesso" => .T., "comentarios" => aRet }

    // =====================
    // AUDITORIA DE OPERAÇÕES
    // =====================
    registraAuditoria(cAcao, cUsuario, cDetalhes)
        Local file := "./auditoria_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "acao" => cAcao, "usuario" => cUsuario, "detalhes" => cDetalhes, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    @Get("/estoque/auditoria")
    action listaAuditoria(params)
        Local file := "./auditoria_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        Return { "sucesso" => .T., "auditoria" => all }

    // =====================
    // API EXTERNA (TOKEN)
    // =====================
    @Post("/estoque/token")
    action geraToken(body)
        Local cUsuario := body["usuario"], cToken := StrTran(GuidGen(), "-", "")
        Local file := "./tokens_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "usuario" => cUsuario, "token" => cToken, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T., "token" => cToken }

    @Post("/estoque/api/consulta")
    action apiConsultaEstoque(body)
        Local cToken := body["token"], cProduto := body["produto"]
        Local file := "./tokens_estoque.json", fs, all, lValido := .F.
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach t IN all
            If t["token"] == cToken
                lValido := .T.
                Exit
            EndIf
        Next
        If !lValido
            Return { "sucesso" => .F., "erro" => "Token inválido." }
        EndIf
        // Consulta estoque simplificada
        Local cQuery := "SELECT B2_COD, B2_LOCAL, B2_QATU FROM SB2 WHERE D_E_L_E_T_ = '' AND B2_COD = '" + cProduto + "'"
        Local aDados := QuerySql(cQuery)
        Return { "sucesso" => .T., "dados" => aDados }

    // =====================
    // INTEGRAÇÃO COM COMPRAS E VENDAS
    // =====================
    @Get("/estoque/integracao/compras-vendas/:produto")
    action integracaoComprasVendas(params)
        Local cProduto, aCompras, aVendas, cQuery, aDados
        cProduto := params["produto"]
        aCompras := {}
        aVendas := {}
        // Compras nos últimos 6 meses
        cQuery := "SELECT SUM(C6_QTDVEN) AS QTDCOMPRA FROM SC6 WHERE C6_PRODUTO = '" + cProduto + "' AND C6_EMISSAO >= '" + DToS(Date() - 180) + "' AND D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            aCompras := aDados[1]["QTDCOMPRA"]
        EndIf
        // Vendas nos últimos 6 meses
        cQuery := "SELECT SUM(D2_QUANT) AS QTDVENDA FROM SD2 WHERE D2_COD = '" + cProduto + "' AND D2_EMISSAO >= '" + DToS(Date() - 180) + "' AND D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            aVendas := aDados[1]["QTDVENDA"]
        EndIf
        Return { "sucesso" => .T., "compras" => aCompras, "vendas" => aVendas }

    // =====================
    // WORKFLOW DE APROVAÇÃO DE MOVIMENTAÇÃO
    // =====================
    @Post("/estoque/workflow/solicitar")
    action solicitarMovimentacao(body)
        Local cProduto, cLocal, nQtd, cTipo, cUsuario, cObs, file, fs, all
        cProduto := body["produto"]
        cLocal := body["local"]
        nQtd := body["quantidade"]
        cTipo := body["tipo"]
        cUsuario := body["usuario"]
        cObs := body["obs"]
        file := "./workflow_mov.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "local" => cLocal, "quantidade" => nQtd, "tipo" => cTipo, "usuario" => cUsuario, "obs" => cObs, "status" => "PENDENTE", "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T., "mensagem" => "Solicitação registrada para aprovação." }

    @Post("/estoque/workflow/aprovar")
    action aprovarMovimentacao(body)
        Local nIdx, file, fs, all, lAchou
        file := "./workflow_mov.json"
        lAchou := .F.
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        For nIdx := 1 To Len(all)
            If all[nIdx]["status"] == "PENDENTE"
                all[nIdx]["status"] := "APROVADO"
                // Executa movimentação real
                This:movimentaEstoque({ "produto" => all[nIdx]["produto"], "local" => all[nIdx]["local"], "quantidade" => all[nIdx]["quantidade"], "tipo" => all[nIdx]["tipo"], "obs" => all[nIdx]["obs"] })
                lAchou := .T.
                Exit
            EndIf
        Next
        MemoWrite(file, JsonEncode(all))
        If lAchou
            Return { "sucesso" => .T., "mensagem" => "Movimentação aprovada e executada." }
        Else
            Return { "sucesso" => .F., "erro" => "Nenhuma movimentação pendente encontrada." }
        EndIf

    @Get("/estoque/workflow/pendentes")
    action listaPendentes(params)
        Local file, fs, all, aRet
        file := "./workflow_mov.json"
        aRet := {}
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach a IN all
            If a["status"] == "PENDENTE"
                aAdd(aRet, a)
            EndIf
        Next
        Return { "sucesso" => .T., "pendentes" => aRet }

    // =====================
    // ALERTAS AUTOMÁTICOS DE RUPTURA/EXCESSO
    // =====================
    @Get("/estoque/alertas")
    action alertasEstoque(params)
        Local aAlertas, cQuery, aDados, nI
        aAlertas := {}
        // Ruptura
        cQuery := "SELECT B2_COD, B2_LOCAL, B2_QATU FROM SB2 WHERE D_E_L_E_T_ = '' AND B2_QATU <= 0"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aAlertas, { "tipo" => "RUPTURA", "produto" => aDados[nI]["B2_COD"], "local" => aDados[nI]["B2_LOCAL"], "saldo" => aDados[nI]["B2_QATU"] })
        Next
        // Excesso
        cQuery := "SELECT SB2.B2_COD, SB2.B2_LOCAL, SB2.B2_QATU, SB1.B1_ESTSEG FROM SB2 INNER JOIN SB1 ON SB2.B2_COD = SB1.B1_COD WHERE SB2.D_E_L_E_T_ = '' AND SB2.B2_QATU > SB1.B1_ESTSEG*2"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aAlertas, { "tipo" => "EXCESSO", "produto" => aDados[nI]["B2_COD"], "local" => aDados[nI]["B2_LOCAL"], "saldo" => aDados[nI]["B2_QATU"] })
        Next
        Return { "sucesso" => .T., "alertas" => aAlertas }

    // =====================
    // ANÁLISE ABC DETALHADA
    // =====================
    @Get("/estoque/abc/detalhado")
    action abcDetalhado(params)
        Local cQuery, aDados, aRet, nTotal, nI, nPerc
        aRet := {}
        nTotal := 0
        nPerc := 0
        // Busca total de vendas
        cQuery := "SELECT SUM(D2_TOTAL) AS TOTAL FROM SD2 WHERE D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nTotal := aDados[1]["TOTAL"]
        EndIf
        // Busca vendas por produto
        cQuery := "SELECT D2_COD, SUM(D2_TOTAL) AS VLR FROM SD2 WHERE D_E_L_E_T_ = '' GROUP BY D2_COD ORDER BY VLR DESC"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            nPerc += (aDados[nI]["VLR"] / nTotal) * 100
            aAdd(aRet, { "produto" => aDados[nI]["D2_COD"], "vendas" => aDados[nI]["VLR"], "perc_acumulado" => nPerc })
        Next
        Return { "sucesso" => .T., "abc" => aRet }

    // =====================
    // INTEGRAÇÃO COM INVENTÁRIO FÍSICO
    // =====================
    @Post("/estoque/inventario/registrar")
    action registrarInventario(body)
        Local cProduto, cLocal, nQtdFisico, cUsuario, file, fs, all
        cProduto := body["produto"]
        cLocal := body["local"]
        nQtdFisico := body["quantidade"]
        cUsuario := body["usuario"]
        file := "./inventario_fisico.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "local" => cLocal, "quantidade_fisico" => nQtdFisico, "usuario" => cUsuario, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T., "mensagem" => "Inventário físico registrado." }

    @Get("/estoque/inventario/:produto/:local")
    action consultaInventario(params)
        Local cProduto, cLocal, file, fs, all, aRet
        cProduto := params["produto"]
        cLocal := params["local"]
        file := "./inventario_fisico.json"
        aRet := {}
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach a IN all
            If a["produto"] == cProduto .And. a["local"] == cLocal
                aAdd(aRet, a)
            EndIf
        Next
        Return { "sucesso" => .T., "inventario" => aRet }
}
