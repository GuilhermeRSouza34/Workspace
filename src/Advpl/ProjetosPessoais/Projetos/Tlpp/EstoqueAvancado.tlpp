// EstoqueAvancado.tlpp
// Sistema avançado de gestão, análise e automação de estoques para Protheus
// Desenvolvido para uso corporativo, com foco em robustez, performance e integração

@Rest
class EstoqueAvancado {
    // =====================
    // CONSULTA DE ESTOQUES
    // =====================
    @Get("/estoque/consulta")
    action consultaEstoque(params) {
        // Parâmetros: produto, local, grupo, saldoMin, saldoMax, curva, page, pageSize, orderBy, orderDir
        const { produto, local, grupo, saldoMin = 0, saldoMax, curva, page = 1, pageSize = 50, orderBy = 'B2_COD', orderDir = 'ASC' } = params;
        let where = ["B2.D_E_L_E_T_ = ''"];
        if (produto) where.push(`B2_COD = '${produto}'`);
        if (local) where.push(`B2_LOCAL = '${local}'`);
        if (grupo) where.push(`B1_GRUPO = '${grupo}'`);
        if (saldoMin) where.push(`B2_QATU >= ${saldoMin}`);
        if (saldoMax) where.push(`B2_QATU <= ${saldoMax}`);
        if (curva) where.push(`B1_CURVA = '${curva}'`);
        let whereStr = where.length ? 'WHERE ' + where.join(' AND ') : '';
        let offset = (parseInt(page) - 1) * parseInt(pageSize);
        let query = `
            SELECT B2_COD, B1_DESC, B2_LOCAL, B2_QATU, B2_QRES, B2_QFUT, B1_GRUPO, B1_CURVA, B2_ULTATU
            FROM SB2
            INNER JOIN SB1 ON B2_COD = B1_COD
            ${whereStr}
            ORDER BY ${orderBy} ${orderDir}
            OFFSET ${offset} ROWS FETCH NEXT ${pageSize} ROWS ONLY
        `;
        let countQuery = `SELECT COUNT(*) as total FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD ${whereStr}`;
        try {
            const itens = QuerySql(query);
            const total = QuerySql(countQuery)[0]?.total || 0;
            this.logConsulta(params, itens.length);
            return { sucesso: true, total, page, pageSize, dados: itens };
        } catch (e) {
            this.logErro('consultaEstoque', e.message, params);
            return { sucesso: false, erro: e.message };
        }
    }

    // =====================
    // DASHBOARD DE ESTOQUE
    // =====================
    @Get("/estoque/dashboard")
    action dashboardEstoque(params)
        Local nTotal := 0, nRuptura := 0, nExcesso := 0, nGiro := 0, aCurva := {}, aLocais := {}, nDias := 90
        Local cQuery, aDados, nI
        // Total em estoque
        cQuery := "SELECT SUM(B2_QATU) AS TOTAL FROM SB2 WHERE D_E_L_E_T_ = ''"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nTotal := aDados[1]["TOTAL"]
        EndIf
        // Produtos em ruptura (saldo <= 0)
        cQuery := "SELECT COUNT(*) AS RUPTURA FROM SB2 WHERE D_E_L_E_T_ = '' AND B2_QATU <= 0"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nRuptura := aDados[1]["RUPTURA"]
        EndIf
        // Produtos em excesso (saldo > B1_ESTSEG*2)
        cQuery := "SELECT COUNT(*) AS EXCESSO FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD WHERE SB2.D_E_L_E_T_ = '' AND B2_QATU > B1_ESTSEG*2"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nExcesso := aDados[1]["EXCESSO"]
        EndIf
        // Giro médio dos últimos 90 dias
        cQuery := "SELECT AVG(MOV.QTDE) AS GIRO FROM (SELECT SUM(D2_QUANT) AS QTDE FROM SD2 WHERE D2_EMISSAO >= '" + DToS(Date() - nDias) + "' AND D_E_L_E_T_ = '' GROUP BY D2_COD) MOV"
        aDados := QuerySql(cQuery)
        If !Empty(aDados)
            nGiro := aDados[1]["GIRO"]
        EndIf
        // Curva ABC
        cQuery := "SELECT B1_CURVA, COUNT(*) AS QTD FROM SB1 WHERE D_E_L_E_T_ = '' GROUP BY B1_CURVA"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aCurva, { aDados[nI]["B1_CURVA"], aDados[nI]["QTD"] })
        Next
        // Estoque por local
        cQuery := "SELECT B2_LOCAL, SUM(B2_QATU) AS QTD FROM SB2 WHERE D_E_L_E_T_ = '' GROUP BY B2_LOCAL"
        aDados := QuerySql(cQuery)
        For nI := 1 To Len(aDados)
            aAdd(aLocais, { aDados[nI]["B2_LOCAL"], aDados[nI]["QTD"] })
        Next
        Return { "sucesso" => .T., "total" => nTotal, "ruptura" => nRuptura, "excesso" => nExcesso, "giro" => nGiro, "curva" => aCurva, "locais" => aLocais }

    // =====================
    // MOVIMENTAÇÃO DE ESTOQUE
    // =====================
    @Post("/estoque/movimentar")
    action movimentaEstoque(body)
        Local cProduto := body["produto"], cLocal := body["local"], nQtd := body["quantidade"], cTipo := body["tipo"], cObs := body["obs"]
        Local cQuery, lOk := .F.
        If Empty(cProduto) .Or. Empty(cLocal) .Or. Empty(nQtd) .Or. Empty(cTipo)
            Return { "sucesso" => .F., "erro" => "Parâmetros obrigatórios ausentes." }
        EndIf
        // Atualiza saldo
        If cTipo == "E"
            cQuery := "UPDATE SB2 SET B2_QATU = B2_QATU + " + AllTrim(Str(nQtd)) + " WHERE B2_COD = '" + cProduto + "' AND B2_LOCAL = '" + cLocal + "' AND D_E_L_E_T_ = ''"
        ElseIf cTipo == "S"
            cQuery := "UPDATE SB2 SET B2_QATU = B2_QATU - " + AllTrim(Str(nQtd)) + " WHERE B2_COD = '" + cProduto + "' AND B2_LOCAL = '" + cLocal + "' AND D_E_L_E_T_ = ''"
        Else
            Return { "sucesso" => .F., "erro" => "Tipo de movimentação inválido." }
        EndIf
        lOk := ExecSql(cQuery)
        If lOk
            // Registra histórico
            This:registraHistoricoMov(cProduto, cLocal, nQtd, cTipo, cObs)
            Return { "sucesso" => .T., "mensagem" => "Movimentação realizada com sucesso." }
        Else
            Return { "sucesso" => .F., "erro" => "Falha ao movimentar estoque." }
        EndIf

    // =====================
    // HISTÓRICO DE MOVIMENTAÇÃO
    // =====================
    @Get("/estoque/historico/:produto/:local")
    action historicoMov(params)
        Local cProduto := params["produto"], cLocal := params["local"]
        Local cQuery, aDados := {}
        If Empty(cProduto) .Or. Empty(cLocal)
            Return { "sucesso" => .F., "erro" => "Informe produto e local." }
        EndIf
        cQuery := "SELECT * FROM HISTMOV WHERE PRODUTO = '" + cProduto + "' AND LOCAL = '" + cLocal + "' ORDER BY DATA DESC"
        aDados := QuerySql(cQuery)
        Return { "sucesso" => .T., "historico" => aDados }

    // Função auxiliar: registra histórico de movimentação
    registraHistoricoMov(cProduto, cLocal, nQtd, cTipo, cObs)
        Local fs, file, all
        file := "./historico_mov.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "local" => cLocal, "quantidade" => nQtd, "tipo" => cTipo, "obs" => cObs, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    // =====================
    // RELATÓRIOS E EXPORTAÇÃO
    // =====================
    @Post("/estoque/relatorio")
    action relatorioEstoque(body)
        Local cCampos := body["campos"], cFiltro := body["filtro"], cOrder := body["order"], cFormato := body["formato"]
        Local cQuery, aDados, cFile, lOk := .F.
        If Empty(cCampos)
            cCampos := "B2_COD, B1_DESC, B2_LOCAL, B2_QATU, B1_GRUPO"
        EndIf
        cQuery := "SELECT " + cCampos + " FROM SB2 INNER JOIN SB1 ON B2_COD = B1_COD WHERE SB2.D_E_L_E_T_ = ''"
        If !Empty(cFiltro)
            cQuery += " AND " + cFiltro
        EndIf
        If !Empty(cOrder)
            cQuery += " ORDER BY " + cOrder
        EndIf
        aDados := QuerySql(cQuery)
        If cFormato == "csv"
            cFile := This:exportaCSV(aDados, cCampos)
        Else
            cFile := This:exportaXLSX(aDados, cCampos)
        EndIf
        Return { "sucesso" => .T., "arquivo" => cFile }

    exportaCSV(aDados, cCampos)
        Local cFile := "./relatorio_estoque.csv", nI, nJ, aCampos, cLinha
        aCampos := StrTokArr(cCampos, ",")
        cLinha := ""
        For nJ := 1 To Len(aCampos)
            cLinha += AllTrim(aCampos[nJ]) + ";"
        Next
        MemoWrite(cFile, cLinha + CRLF)
        For nI := 1 To Len(aDados)
            cLinha := ""
            For nJ := 1 To Len(aCampos)
                cLinha += AllTrim(Str(aDados[nI][AllTrim(aCampos[nJ])])) + ";"
            Next
            MemoWrite(cFile, MemoRead(cFile) + cLinha + CRLF)
        Next
        Return cFile

    exportaXLSX(aDados, cCampos)
        // Placeholder: exportação XLSX pode ser feita via integração externa ou rotina customizada
        Return "./relatorio_estoque.xlsx"

    // =====================
    // UPLOAD DE DOCUMENTOS
    // =====================
    @Post("/estoque/upload/:produto")
    action uploadDoc(params, req)
        Local cProduto := params["produto"], cNome := req["filename"], cConteudo := req["filedata"]
        Local cDir := "./docs_estoque/" + cProduto, cFile
        If !Directory(cDir)
            MakeDir(cDir)
        EndIf
        cFile := cDir + "/" + cNome
        MemoWrite(cFile, cConteudo)
        This:registraDocProduto(cProduto, cNome, cFile)
        Return { "sucesso" => .T., "mensagem" => "Documento salvo." }

    registraDocProduto(cProduto, cNome, cFile)
        Local fs, file, all
        file := "./docs_estoque.json"
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "nome" => cNome, "caminho" => cFile, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    // =====================
    // COMENTÁRIOS/OCORRÊNCIAS
    // =====================
    @Post("/estoque/comentario/:produto")
    action comentaProduto(params, body)
        Local cProduto := params["produto"], cUsuario := body["usuario"], cTexto := body["comentario"]
        Local file := "./comentarios_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "produto" => cProduto, "usuario" => cUsuario, "comentario" => cTexto, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T. }

    @Get("/estoque/comentarios/:produto")
    action listaComentarios(params)
        Local cProduto := params["produto"], file := "./comentarios_estoque.json", fs, all, aRet := {}
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach a IN all
            If a["produto"] == cProduto
                aAdd(aRet, a)
            EndIf
        Next
        Return { "sucesso" => .T., "comentarios" => aRet }

    // =====================
    // AUDITORIA DE OPERAÇÕES
    // =====================
    registraAuditoria(cAcao, cUsuario, cDetalhes)
        Local file := "./auditoria_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "acao" => cAcao, "usuario" => cUsuario, "detalhes" => cDetalhes, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))

    @Get("/estoque/auditoria")
    action listaAuditoria(params)
        Local file := "./auditoria_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        Return { "sucesso" => .T., "auditoria" => all }

    // =====================
    // API EXTERNA (TOKEN)
    // =====================
    @Post("/estoque/token")
    action geraToken(body)
        Local cUsuario := body["usuario"], cToken := StrTran(GuidGen(), "-", "")
        Local file := "./tokens_estoque.json", fs, all
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        aAdd(all, { "usuario" => cUsuario, "token" => cToken, "data" => DToS(Date()) })
        MemoWrite(file, JsonEncode(all))
        Return { "sucesso" => .T., "token" => cToken }

    @Post("/estoque/api/consulta")
    action apiConsultaEstoque(body)
        Local cToken := body["token"], cProduto := body["produto"]
        Local file := "./tokens_estoque.json", fs, all, lValido := .F.
        all := {}
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        ForEach t IN all
            If t["token"] == cToken
                lValido := .T.
                Exit
            EndIf
        Next
        If !lValido
            Return { "sucesso" => .F., "erro" => "Token inválido." }
        EndIf
        // Consulta estoque simplificada
        Local cQuery := "SELECT B2_COD, B2_LOCAL, B2_QATU FROM SB2 WHERE D_E_L_E_T_ = '' AND B2_COD = '" + cProduto + "'"
        Local aDados := QuerySql(cQuery)
        Return { "sucesso" => .T., "dados" => aDados }
}
