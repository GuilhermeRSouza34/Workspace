#include "tlpp-core.th"
#include "tlpp-rest.th"

/*
 * QualidadeAvancada.tlpp
 * Centro de Controle de Qualidade Avançado - Sistema Completo
 * 
 * Autor: Guilherme Souza
 * Data: 05/08/2025
 * 
 * Descrição: Sistema avançado de gestão de qualidade com automações inteligentes,
 *           análise de tendências, rastreabilidade completa e otimização de processos.
 *           Utiliza apenas recursos nativos do Protheus.
 * 
 * Funcionalidades:
 * - Parte 1: Dashboard e Análise de Tendências
 * - Parte 2: Planos de Amostragem Dinâmicos e Certificados Automáticos  
 * - Parte 3: Rastreabilidade Completa e Calibração de Equipamentos
 * - Parte 4: Auditorias Automáticas e Relatórios Avançados
 * - Parte 5: Integrações e Utilitários de Qualidade
 * 
 * Versão: 1.0
 */

Namespace QualidadeAvancada

Using Namespace tlpp.core
Using Namespace tlpp.rest

/*
 * Classe principal do sistema de qualidade avançado
 */
@RestClass()
Class QualidadeAvancada

    // =====================================================================
    // PARTE 1: DASHBOARD E ANÁLISE DE TENDÊNCIAS
    // =====================================================================

    /*
     * Dashboard principal do sistema de qualidade
     * Retorna KPIs principais, indicadores e métricas em tempo real
     */
    @Get("/qualidade/dashboard")
    action dashboardQualidade(params)
        Local dDataIni, dDataFim, cProduto, cFornecedor, oDashboard, aKPIs
        Local nTotalEnsaios, nEnsaiosAprovados, nTaxaConformidade, nCustoQualidade
        Local aProdutosCriticos, aFornecedoresRisco, aNotificacoes, lErro, cErro
        
        dDataIni := Iif(!Empty(params["dataInicio"]), SToD(StrTran(params["dataInicio"], "-", "")), Date() - 30)
        dDataFim := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"], "-", "")), Date())
        cProduto := Iif(params["produto"] != Nil, AllTrim(params["produto"]), "")
        cFornecedor := Iif(params["fornecedor"] != Nil, AllTrim(params["fornecedor"]), "")
        
        lErro := .F.
        cErro := ""
        aKPIs := {}
        aProdutosCriticos := {}
        aFornecedoresRisco := {}
        aNotificacoes := {}
        
        Begin Sequence
            // KPI 1: Taxa de Conformidade Geral
            aKPIs := This:calculaKPIsQualidade(dDataIni, dDataFim, cProduto, cFornecedor)
            
            // KPI 2: Produtos Críticos (maior índice de não conformidade)
            aProdutosCriticos := This:identificaProdutosCriticos(dDataIni, dDataFim)
            
            // KPI 3: Fornecedores em Risco
            aFornecedoresRisco := This:analisaFornecedoresRisco(dDataIni, dDataFim)
            
            // KPI 4: Notificações e Alertas
            aNotificacoes := This:gerarNotificacoesQualidade()
            
            oDashboard := {;
                "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim),;
                "dataAtualizacao" => DToS(Date()) + " " + Time(),;
                "kpis" => aKPIs,;
                "produtosCriticos" => aProdutosCriticos,;
                "fornecedoresRisco" => aFornecedoresRisco,;
                "notificacoes" => aNotificacoes,;
                "alertas" => This:verificarAlertasCriticos();
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao gerar dashboard: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("dashboardQualidade", "SISTEMA", {"periodo" => DToS(dDataIni) + "-" + DToS(dDataFim)}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "dashboard" => oDashboard }

    /*
     * Análise avançada de tendências de qualidade por produto
     * Utiliza algoritmos estatísticos para identificar padrões
     */
    @Get("/qualidade/tendencias/:produto")
    action analisarTendencias(params)
        Local cProduto, dDataIni, dDataFim, aTendencias, aEstatisticas, aDados
        Local aMediaMovel, aDesvios, aProjecoes, aRecomendacoes, lErro, cErro
        
        cProduto := AllTrim(params["produto"])
        dDataIni := Iif(!Empty(params["dataInicio"]), SToD(StrTran(params["dataInicio"], "-", "")), Date() - 90)
        dDataFim := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"], "-", "")), Date())
        
        lErro := .F.
        cErro := ""
        aTendencias := {}
        
        If Empty(cProduto)
            Return { "sucesso" => .F., "erro" => "Código do produto é obrigatório" }
        EndIf
        
        Begin Sequence
            // Coleta dados históricos de ensaios
            aDados := This:coletaDadosHistoricos(cProduto, dDataIni, dDataFim)
            
            If Empty(aDados)
                Return { "sucesso" => .F., "erro" => "Nenhum dado encontrado para o período" }
            EndIf
            
            // Calcula estatísticas básicas
            aEstatisticas := This:calculaEstatisticasBasicas(aDados)
            
            // Análise de média móvel (7 períodos)
            aMediaMovel := This:calculaMediaMovel(aDados, 7)
            
            // Análise de desvios e outliers
            aDesvios := This:identificaDesvios(aDados, aEstatisticas["media"], aEstatisticas["desvio"])
            
            // Projeções futuras baseadas em tendência
            aProjecoes := This:calcularProjecoesTendencia(aDados, 30) // 30 dias à frente
            
            // Recomendações baseadas na análise
            aRecomendacoes := This:gerarRecomendacoesTendencia(aEstatisticas, aDesvios, aProjecoes)
            
            aTendencias := {;
                "produto" => cProduto,;
                "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim),;
                "totalEnsaios" => Len(aDados),;
                "estatisticas" => aEstatisticas,;
                "mediaMovel" => aMediaMovel,;
                "desvios" => aDesvios,;
                "projecoes" => aProjecoes,;
                "recomendacoes" => aRecomendacoes,;
                "indiceQualidade" => This:calculaIndiceQualidade(aEstatisticas);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na análise de tendências: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("analisarTendencias", "SISTEMA", {"produto" => cProduto}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "analise" => aTendencias }

    /*
     * Análise comparativa de qualidade entre períodos
     * Permite comparar performance atual vs período anterior
     */
    @Post("/qualidade/comparativo")
    action analiseComparativa(body)
        Local dPeriodo1Ini, dPeriodo1Fim, dPeriodo2Ini, dPeriodo2Fim, cFiltro
        Local aResultados1, aResultados2, oComparativo, nVariacao, lErro, cErro
        
        dPeriodo1Ini := SToD(StrTran(body["periodo1"]["inicio"], "-", ""))
        dPeriodo1Fim := SToD(StrTran(body["periodo1"]["fim"], "-", ""))
        dPeriodo2Ini := SToD(StrTran(body["periodo2"]["inicio"], "-", ""))
        dPeriodo2Fim := SToD(StrTran(body["periodo2"]["fim"], "-", ""))
        cFiltro := Iif(body["filtro"] != Nil, AllTrim(body["filtro"]), "")
        
        lErro := .F.
        cErro := ""
        
        If Empty(dPeriodo1Ini) .Or. Empty(dPeriodo1Fim) .Or. Empty(dPeriodo2Ini) .Or. Empty(dPeriodo2Fim)
            Return { "sucesso" => .F., "erro" => "Todos os períodos são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Analisa primeiro período
            aResultados1 := This:analisaPeriodo(dPeriodo1Ini, dPeriodo1Fim, cFiltro)
            
            // Analisa segundo período
            aResultados2 := This:analisaPeriodo(dPeriodo2Ini, dPeriodo2Fim, cFiltro)
            
            // Calcula variações
            nVariacao := This:calculaVariacaoPercentual(aResultados1["taxaConformidade"], aResultados2["taxaConformidade"])
            
            oComparativo := {;
                "periodo1" => {;
                    "inicio" => DToS(dPeriodo1Ini),;
                    "fim" => DToS(dPeriodo1Fim),;
                    "resultados" => aResultados1;
                },;
                "periodo2" => {;
                    "inicio" => DToS(dPeriodo2Ini),;
                    "fim" => DToS(dPeriodo2Fim),;
                    "resultados" => aResultados2;
                },;
                "variacao" => {;
                    "taxaConformidade" => nVariacao,;
                    "tendencia" => Iif(nVariacao > 0, "MELHORIA", Iif(nVariacao < 0, "PIORA", "ESTÁVEL")),;
                    "significativa" => Abs(nVariacao) > 5;
                },;
                "analise" => This:gerarAnaliseComparativa(aResultados1, aResultados2, nVariacao);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na análise comparativa: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("analiseComparativa", "SISTEMA", {"filtro" => cFiltro}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "comparativo" => oComparativo }

    /*
     * Monitor de alertas críticos de qualidade
     * Sistema de early warning para problemas de qualidade
     */
    @Get("/qualidade/alertas")
    action monitorAlertas(params)
        Local cTipo, cPrioridade, aAlertas, aAlertasCriticos, aAlertasPreventivos
        Local lErro, cErro, nTotal
        
        cTipo := Iif(params["tipo"] != Nil, AllTrim(params["tipo"]), "TODOS")
        cPrioridade := Iif(params["prioridade"] != Nil, AllTrim(params["prioridade"]), "TODAS")
        
        lErro := .F.
        cErro := ""
        aAlertas := {}
        
        Begin Sequence
            // Alertas críticos (requerem ação imediata)
            aAlertasCriticos := This:verificarAlertasCriticos()
            
            // Alertas preventivos (tendências preocupantes)
            aAlertasPreventivos := This:verificarAlertasPreventivos()
            
            // Filtra por tipo se especificado
            If cTipo == "CRITICOS"
                aAlertas := aAlertasCriticos
            ElseIf cTipo == "PREVENTIVOS"
                aAlertas := aAlertasPreventivos
            Else
                aAlertas := aAlertasCriticos
                aEval(aAlertasPreventivos, {|x| aAdd(aAlertas, x)})
            EndIf
            
            // Filtra por prioridade se especificado
            If cPrioridade != "TODAS"
                aAlertas := aFilter(aAlertas, {|x| x["prioridade"] == cPrioridade})
            EndIf
            
            nTotal := Len(aAlertas)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao buscar alertas: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "alertas" => aAlertas, "total" => nTotal, "dataConsulta" => DToS(Date()) + " " + Time() }

    // =====================================================================
    // PARTE 2: PLANOS DE AMOSTRAGEM DINÂMICOS E CERTIFICADOS AUTOMÁTICOS
    // =====================================================================

    /*
     * Otimizador de planos de amostragem baseado em histórico de qualidade
     * Ajusta automaticamente o tamanho da amostra baseado na performance
     */
    @Post("/qualidade/otimizar-amostragem")
    action otimizarAmostragem(body)
        Local cProduto, cFornecedor, nPeriodoAnalise, aPlanos, oPlano, nI
        Local nTaxaConformidade, nNovoTamanho, cJustificativa, lErro, cErro
        
        cProduto := Iif(body["produto"] != Nil, AllTrim(body["produto"]), "")
        cFornecedor := Iif(body["fornecedor"] != Nil, AllTrim(body["fornecedor"]), "")
        nPeriodoAnalise := Iif(body["periodoAnalise"] != Nil, body["periodoAnalise"], 90)
        
        lErro := .F.
        cErro := ""
        aPlanos := {}
        
        Begin Sequence
            // Busca planos de amostragem atuais
            aPlanos := This:buscarPlanosAmostragem(cProduto, cFornecedor)
            
            For nI := 1 To Len(aPlanos)
                oPlano := aPlanos[nI]
                
                // Analisa histórico de qualidade
                nTaxaConformidade := This:calcularTaxaConformidade(oPlano["produto"], oPlano["fornecedor"], nPeriodoAnalise)
                
                // Aplica algoritmo de otimização
                nNovoTamanho := This:calcularNovoTamanhoAmostra(oPlano["tamanhoAtual"], nTaxaConformidade, oPlano["criticidade"])
                
                // Gera justificativa da mudança
                cJustificativa := This:gerarJustificativaAmostragem(nTaxaConformidade, oPlano["tamanhoAtual"], nNovoTamanho)
                
                // Atualiza plano se houve mudança significativa
                If Abs(nNovoTamanho - oPlano["tamanhoAtual"]) > 1
                    This:atualizarPlanoAmostragem(oPlano["codigo"], nNovoTamanho, cJustificativa)
                    oPlano["novoTamanho"] := nNovoTamanho
                    oPlano["alterado"] := .T.
                    oPlano["justificativa"] := cJustificativa
                Else
                    oPlano["novoTamanho"] := oPlano["tamanhoAtual"]
                    oPlano["alterado"] := .F.
                    oPlano["justificativa"] := "Tamanho da amostra mantido - performance estável"
                EndIf
                
                oPlano["taxaConformidade"] := nTaxaConformidade
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na otimização de amostragem: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("otimizarAmostragem", "SISTEMA", {"produto" => cProduto, "fornecedor" => cFornecedor}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "planos" => aPlanos, "totalPlanos" => Len(aPlanos), "dataOtimizacao" => DToS(Date()) }

    /*
     * Gerador automático de certificados de qualidade
     * Cria certificados baseados em templates e resultados de ensaios
     */
    @Post("/qualidade/gerar-certificado")
    action gerarCertificado(body)
        Local cLote, cProduto, cTipoCertificado, cTemplate, cDestinatario
        Local aDadosEnsaios, oCertificado, cConteudo, cNomeArquivo, lErro, cErro
        
        cLote := AllTrim(body["lote"])
        cProduto := AllTrim(body["produto"])
        cTipoCertificado := AllTrim(body["tipoCertificado"]) // CONFORMIDADE, ANALISE, LAUDO
        cTemplate := Iif(body["template"] != Nil, AllTrim(body["template"]), "")
        cDestinatario := Iif(body["destinatario"] != Nil, AllTrim(body["destinatario"]), "")
        
        lErro := .F.
        cErro := ""
        
        If Empty(cLote) .Or. Empty(cProduto) .Or. Empty(cTipoCertificado)
            Return { "sucesso" => .F., "erro" => "Lote, produto e tipo de certificado são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Busca dados dos ensaios do lote
            aDadosEnsaios := This:buscarDadosEnsaios(cLote, cProduto)
            
            If Empty(aDadosEnsaios)
                Return { "sucesso" => .F., "erro" => "Nenhum ensaio encontrado para o lote especificado" }
            EndIf
            
            // Verifica se lote foi aprovado
            If !This:verificarLoteAprovado(aDadosEnsaios)
                Return { "sucesso" => .F., "erro" => "Certificado só pode ser gerado para lotes aprovados" }
            EndIf
            
            // Busca template do certificado
            If Empty(cTemplate)
                cTemplate := This:buscarTemplatePadrao(cTipoCertificado)
            EndIf
            
            // Gera conteúdo do certificado
            cConteudo := This:montarCertificado(cTemplate, aDadosEnsaios, cTipoCertificado)
            
            // Gera nome do arquivo
            cNomeArquivo := This:gerarNomeArquivoCertificado(cLote, cProduto, cTipoCertificado)
            
            // Salva certificado
            MemoWrite(cNomeArquivo, cConteudo)
            
            // Registra certificado no sistema
            oCertificado := {;
                "lote" => cLote,;
                "produto" => cProduto,;
                "tipoCertificado" => cTipoCertificado,;
                "nomeArquivo" => cNomeArquivo,;
                "dataGeracao" => DToS(Date()),;
                "horaGeracao" => Time(),;
                "destinatario" => cDestinatario,;
                "status" => "GERADO";
            }
            
            This:registrarCertificado(oCertificado)
            
            // Envia por email se destinatário especificado
            If !Empty(cDestinatario)
                This:enviarCertificadoPorEmail(oCertificado, cDestinatario)
                oCertificado["emailEnviado"] := .T.
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na geração do certificado: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("gerarCertificado", "SISTEMA", {"lote" => cLote, "tipo" => cTipoCertificado}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "certificado" => oCertificado, "arquivo" => cNomeArquivo }

    /*
     * Sistema de monitoramento automático de lotes
     * Monitora ensaios em andamento e dispara ações automáticas
     */
    @Get("/qualidade/monitorar-lotes")
    action monitorarLotes(params)
        Local cStatus, dDataIni, dDataFim, aLotes, aLotesMonitorados, nI, oLote
        Local aAcoesDisparo, lErro, cErro
        
        cStatus := Iif(params["status"] != Nil, AllTrim(params["status"]), "TODOS")
        dDataIni := Iif(!Empty(params["dataInicio"]), SToD(StrTran(params["dataInicio"], "-", "")), Date() - 7)
        dDataFim := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"], "-", "")), Date())
        
        lErro := .F.
        cErro := ""
        aLotesMonitorados := {}
        aAcoesDisparo := {}
        
        Begin Sequence
            // Busca lotes no período
            aLotes := This:buscarLotesEnsaios(dDataIni, dDataFim, cStatus)
            
            For nI := 1 To Len(aLotes)
                oLote := aLotes[nI]
                
                // Verifica status atual do lote
                oLote["statusAtual"] := This:verificarStatusLote(oLote["lote"], oLote["produto"])
                
                // Verifica se precisa de ações automáticas
                If oLote["statusAtual"] == "APROVADO"
                    // Verifica se certificado já foi gerado
                    If !This:certificadoJaGerado(oLote["lote"], oLote["produto"])
                        aAdd(aAcoesDisparo, {;
                            "acao" => "GERAR_CERTIFICADO",;
                            "lote" => oLote["lote"],;
                            "produto" => oLote["produto"],;
                            "prioridade" => "MEDIA";
                        })
                    EndIf
                    
                    // Verifica se precisa atualizar estoque
                    If This:precisaAtualizarEstoque(oLote["lote"])
                        aAdd(aAcoesDisparo, {;
                            "acao" => "LIBERAR_ESTOQUE",;
                            "lote" => oLote["lote"],;
                            "produto" => oLote["produto"],;
                            "prioridade" => "ALTA";
                        })
                    EndIf
                    
                ElseIf oLote["statusAtual"] == "REPROVADO"
                    // Verifica se precisa de ação corretiva
                    aAdd(aAcoesDisparo, {;
                        "acao" => "ACAO_CORRETIVA",;
                        "lote" => oLote["lote"],;
                        "produto" => oLote["produto"],;
                        "prioridade" => "CRITICA";
                    })
                    
                ElseIf oLote["statusAtual"] == "PENDENTE"
                    // Verifica se ensaio está em atraso
                    If This:ensaioEmAtraso(oLote["dataRecebimento"])
                        aAdd(aAcoesDisparo, {;
                            "acao" => "ALERTA_ATRASO",;
                            "lote" => oLote["lote"],;
                            "produto" => oLote["produto"],;
                            "prioridade" => "MEDIA";
                        })
                    EndIf
                EndIf
                
                aAdd(aLotesMonitorados, oLote)
            Next
            
            // Executa ações de disparo
            This:executarAcoesAutomaticas(aAcoesDisparo)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no monitoramento de lotes: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("monitorarLotes", "SISTEMA", {"periodo" => DToS(dDataIni) + "-" + DToS(dDataFim)}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "lotes" => aLotesMonitorados, "acoes" => aAcoesDisparo, "totalLotes" => Len(aLotesMonitorados) }

    /*
     * Gerador de templates de certificados personalizáveis
     * Permite criar e gerenciar templates de certificados
     */
    @Post("/qualidade/templates/criar")
    action criarTemplate(body)
        Local cNome, cTipo, cConteudo, cDescricao, aCamposDinamicos
        Local oTemplate, cCodigo, lErro, cErro
        
        cNome := AllTrim(body["nome"])
        cTipo := AllTrim(body["tipo"])
        cConteudo := body["conteudo"]
        cDescricao := Iif(body["descricao"] != Nil, body["descricao"], "")
        aCamposDinamicos := Iif(body["camposDinamicos"] != Nil, body["camposDinamicos"], {})
        
        lErro := .F.
        cErro := ""
        
        If Empty(cNome) .Or. Empty(cTipo) .Or. Empty(cConteudo)
            Return { "sucesso" => .F., "erro" => "Nome, tipo e conteúdo são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Gera código único do template
            cCodigo := This:gerarCodigoTemplate(cTipo)
            
            // Valida campos dinâmicos
            This:validarCamposDinamicos(aCamposDinamicos)
            
            oTemplate := {;
                "codigo" => cCodigo,;
                "nome" => cNome,;
                "tipo" => cTipo,;
                "descricao" => cDescricao,;
                "conteudo" => cConteudo,;
                "camposDinamicos" => aCamposDinamicos,;
                "dataCriacao" => DToS(Date()),;
                "horaCriacao" => Time(),;
                "ativo" => .T.;
            }
            
            // Salva template
            This:salvarTemplate(oTemplate)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao criar template: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("criarTemplate", "SISTEMA", {"nome" => cNome, "tipo" => cTipo}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "template" => oTemplate, "codigo" => cCodigo }

    // =====================================================================
    // MÉTODOS AUXILIARES - PARTE 2
    // =====================================================================
    
    /*
     * Busca planos de amostragem ativos no sistema
     */
    Method buscarPlanosAmostragem(cProduto, cFornecedor)
        Local cQuery, aDados, aPlanos, nI, oPlano
        
        cQuery := "SELECT QM0_CODIGO, QM0_PRODUT, QM0_FORNEC, QM0_LOJFOR, QM0_TAMANH, " +;
                 "B1_DESC, A2_NOME FROM QM0010 QM0 " +;
                 "INNER JOIN SB1010 SB1 ON QM0_PRODUT = B1_COD AND SB1.D_E_L_E_T_ = '' " +;
                 "LEFT JOIN SA2010 SA2 ON QM0_FORNEC = A2_COD AND QM0_LOJFOR = A2_LOJA AND SA2.D_E_L_E_T_ = '' " +;
                 "WHERE QM0.D_E_L_E_T_ = ''"
        
        If !Empty(cProduto)
            cQuery += " AND QM0_PRODUT = '" + cProduto + "'"
        EndIf
        
        If !Empty(cFornecedor)
            cQuery += " AND QM0_FORNEC = '" + cFornecedor + "'"
        EndIf
        
        aDados := This:executarQuery(cQuery)
        aPlanos := {}
        
        For nI := 1 To Len(aDados)
            oPlano := {;
                "codigo" => aDados[nI]["QM0_CODIGO"],;
                "produto" => aDados[nI]["QM0_PRODUT"],;
                "descricaoProduto" => aDados[nI]["B1_DESC"],;
                "fornecedor" => aDados[nI]["QM0_FORNEC"],;
                "loja" => aDados[nI]["QM0_LOJFOR"],;
                "nomeFornecedor" => aDados[nI]["A2_NOME"],;
                "tamanhoAtual" => aDados[nI]["QM0_TAMANH"],;
                "criticidade" => This:obterCriticidadeProduto(aDados[nI]["QM0_PRODUT"]);
            }
            aAdd(aPlanos, oPlano)
        Next
        
        Return aPlanos

    /*
     * Calcula taxa de conformidade para produto/fornecedor
     */
    Method calcularTaxaConformidade(cProduto, cFornecedor, nPeriodo)
        Local cQuery, aDados, nTaxaConformidade, dDataIni
        
        dDataIni := Date() - nPeriodo
        
        cQuery := "SELECT COUNT(*) AS TOTAL, " +;
                 "SUM(CASE WHEN QAD_RLAUDO IN ('1','3') THEN 1 ELSE 0 END) AS APROVADOS " +;
                 "FROM QAD010 WHERE D_E_L_E_T_ = '' " +;
                 "AND QAD_PRODUT = '" + cProduto + "'" +;
                 "AND QAD_DTENTR >= '" + DToS(dDataIni) + "'"
        
        If !Empty(cFornecedor)
            cQuery += " AND QAD_FORNEC = '" + cFornecedor + "'"
        EndIf
        
        aDados := This:executarQuery(cQuery)
        
        If !Empty(aDados) .And. aDados[1]["TOTAL"] > 0
            nTaxaConformidade := Round((aDados[1]["APROVADOS"] / aDados[1]["TOTAL"]) * 100, 2)
        Else
            nTaxaConformidade := 95 // Valor padrão se não há histórico
        EndIf
        
        Return nTaxaConformidade

    /*
     * Algoritmo para calcular novo tamanho de amostra
     */
    Method calcularNovoTamanhoAmostra(nTamanhoAtual, nTaxaConformidade, cCriticidade)
        Local nNovoTamanho, nFatorAjuste, nMinimo, nMaximo
        
        // Define limites baseados na criticidade
        If cCriticidade == "ALTA"
            nMinimo := 5
            nMaximo := 50
        ElseIf cCriticidade == "MEDIA"
            nMinimo := 3
            nMaximo := 30
        Else
            nMinimo := 2
            nMaximo := 20
        EndIf
        
        // Algoritmo de ajuste baseado na taxa de conformidade
        If nTaxaConformidade >= 99
            nFatorAjuste := 0.7  // Reduz 30%
        ElseIf nTaxaConformidade >= 98
            nFatorAjuste := 0.8  // Reduz 20%
        ElseIf nTaxaConformidade >= 95
            nFatorAjuste := 0.9  // Reduz 10%
        ElseIf nTaxaConformidade >= 90
            nFatorAjuste := 1.0  // Mantém
        ElseIf nTaxaConformidade >= 85
            nFatorAjuste := 1.2  // Aumenta 20%
        Else
            nFatorAjuste := 1.5  // Aumenta 50%
        EndIf
        
        nNovoTamanho := Round(nTamanhoAtual * nFatorAjuste, 0)
        
        // Aplica limites
        nNovoTamanho := Max(nMinimo, Min(nMaximo, nNovoTamanho))
        
        Return nNovoTamanho

    /*
     * Gera justificativa para mudança de amostragem
     */
    Method gerarJustificativaAmostragem(nTaxaConformidade, nTamanhoAtual, nNovoTamanho)
        Local cJustificativa
        
        If nNovoTamanho > nTamanhoAtual
            cJustificativa := "Aumento de " + cValToChar(nTamanhoAtual) + " para " + cValToChar(nNovoTamanho) + ;
                            " devido à taxa de conformidade de " + cValToChar(nTaxaConformidade) + "% (abaixo do esperado)"
        ElseIf nNovoTamanho < nTamanhoAtual
            cJustificativa := "Redução de " + cValToChar(nTamanhoAtual) + " para " + cValToChar(nNovoTamanho) + ;
                            " devido à excelente taxa de conformidade de " + cValToChar(nTaxaConformidade) + "%"
        Else
            cJustificativa := "Tamanho mantido em " + cValToChar(nTamanhoAtual) + ;
                            " - taxa de conformidade de " + cValToChar(nTaxaConformidade) + "% adequada"
        EndIf
        
        Return cJustificativa

    /*
     * Busca dados dos ensaios para um lote específico
     */
    Method buscarDadosEnsaios(cLote, cProduto)
        Local cQuery, aDados, aEnsaios, nI, oEnsaio
        
        cQuery := "SELECT QAD_LOTE, QAD_PRODUT, QAD_ENSAIO, QAD_RLAUDO, QAD_DTENTR, " +;
                 "QAD_TPRES, QAD_RESULT, QAE_DESC FROM QAD010 QAD " +;
                 "INNER JOIN QAE010 QAE ON QAD_ENSAIO = QAE_ENSAIO AND QAE.D_E_L_E_T_ = '' " +;
                 "WHERE QAD.D_E_L_E_T_ = '' " +;
                 "AND QAD_LOTE = '" + cLote + "' AND QAD_PRODUT = '" + cProduto + "'"
        
        aDados := This:executarQuery(cQuery)
        aEnsaios := {}
        
        For nI := 1 To Len(aDados)
            oEnsaio := {;
                "lote" => aDados[nI]["QAD_LOTE"],;
                "produto" => aDados[nI]["QAD_PRODUT"],;
                "ensaio" => aDados[nI]["QAD_ENSAIO"],;
                "descricaoEnsaio" => aDados[nI]["QAE_DESC"],;
                "resultado" => aDados[nI]["QAD_RESULT"],;
                "laudo" => aDados[nI]["QAD_RLAUDO"],;
                "dataEnsaio" => aDados[nI]["QAD_DTENTR"],;
                "tipoResultado" => aDados[nI]["QAD_TPRES"];
            }
            aAdd(aEnsaios, oEnsaio)
        Next
        
        Return aEnsaios

    /*
     * Verifica se lote foi aprovado em todos os ensaios
     */
    Method verificarLoteAprovado(aDadosEnsaios)
        Local nI, lAprovado
        
        lAprovado := .T.
        
        For nI := 1 To Len(aDadosEnsaios)
            If !(aDadosEnsaios[nI]["laudo"] $ "1|3") // 1=Aprovado, 3=Aprovado com restrição
                lAprovado := .F.
                Exit
            EndIf
        Next
        
        Return lAprovado

    /*
     * Monta conteúdo do certificado baseado no template
     */
    Method montarCertificado(cTemplate, aDadosEnsaios, cTipoCertificado)
        Local cConteudo, nI, oEnsaio, cResultados, dDataCertificado
        
        dDataCertificado := Date()
        cResultados := ""
        
        // Monta tabela de resultados
        For nI := 1 To Len(aDadosEnsaios)
            oEnsaio := aDadosEnsaios[nI]
            cResultados += oEnsaio["descricaoEnsaio"] + ": " + oEnsaio["resultado"] + " - " + ;
                          Iif(oEnsaio["laudo"] == "1", "APROVADO", Iif(oEnsaio["laudo"] == "3", "APROVADO C/ RESTRIÇÃO", "REPROVADO")) + CRLF
        Next
        
        // Substitui campos dinâmicos no template
        cConteudo := StrTran(cTemplate, "{LOTE}", aDadosEnsaios[1]["lote"])
        cConteudo := StrTran(cConteudo, "{PRODUTO}", aDadosEnsaios[1]["produto"])
        cConteudo := StrTran(cConteudo, "{DATA_CERTIFICADO}", DToC(dDataCertificado))
        cConteudo := StrTran(cConteudo, "{RESULTADOS}", cResultados)
        cConteudo := StrTran(cConteudo, "{TIPO_CERTIFICADO}", cTipoCertificado)
        
        Return cConteudo

    /*
     * Busca template padrão por tipo de certificado
     */
    Method buscarTemplatePadrao(cTipoCertificado)
        Local cTemplate
        
        If cTipoCertificado == "CONFORMIDADE"
            cTemplate := "CERTIFICADO DE CONFORMIDADE" + CRLF + CRLF +;
                        "Lote: {LOTE}" + CRLF +;
                        "Produto: {PRODUTO}" + CRLF +;
                        "Data: {DATA_CERTIFICADO}" + CRLF + CRLF +;
                        "Resultados dos Ensaios:" + CRLF +;
                        "{RESULTADOS}" + CRLF +;
                        "Este produto atende aos requisitos especificados."
        ElseIf cTipoCertificado == "ANALISE"
            cTemplate := "CERTIFICADO DE ANÁLISE" + CRLF + CRLF +;
                        "Lote: {LOTE}" + CRLF +;
                        "Produto: {PRODUTO}" + CRLF +;
                        "Data: {DATA_CERTIFICADO}" + CRLF + CRLF +;
                        "Resultados Analíticos:" + CRLF +;
                        "{RESULTADOS}"
        Else
            cTemplate := "LAUDO TÉCNICO" + CRLF + CRLF +;
                        "Lote: {LOTE}" + CRLF +;
                        "Produto: {PRODUTO}" + CRLF +;
                        "Data: {DATA_CERTIFICADO}" + CRLF + CRLF +;
                        "Resultados:" + CRLF +;
                        "{RESULTADOS}"
        EndIf
        
        Return cTemplate

    /*
     * Obtem criticidade do produto para cálculo de amostragem
     */
    Method obterCriticidadeProduto(cProduto)
        Local cQuery, aDados, cCriticidade
        
        // Busca no cadastro de produtos campo customizado de criticidade
        cQuery := "SELECT B1_XCRIT FROM SB1010 WHERE D_E_L_E_T_ = '' AND B1_COD = '" + cProduto + "'"
        aDados := This:executarQuery(cQuery)
        
        If !Empty(aDados) .And. !Empty(aDados[1]["B1_XCRIT"])
            cCriticidade := aDados[1]["B1_XCRIT"]
        Else
            cCriticidade := "MEDIA" // Valor padrão
        EndIf
        
        Return cCriticidade

    /*
     * Registra certificado gerado no controle interno
     */
    Method registrarCertificado(oCertificado)
        Local file, fs, all
        
        file := "./certificados_gerados.json"
        all := {}
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        
        aAdd(all, oCertificado)
        MemoWrite(file, JsonEncode(all))
        
        Return .T.

    /*
     * Gera nome único para arquivo de certificado
     */
    Method gerarNomeArquivoCertificado(cLote, cProduto, cTipoCertificado)
        Local cNome
        
        cNome := "./certificados/CERT_" + AllTrim(cTipoCertificado) + "_" + ;
                AllTrim(cProduto) + "_" + AllTrim(cLote) + "_" + ;
                DToS(Date()) + "_" + StrTran(Time(), ":", "") + ".txt"
        
        Return cNome

    // =====================================================================
    // MÉTODOS AUXILIARES - PARTE 1
    // =====================================================================
    
    /*
     * Calcula KPIs principais de qualidade
     */
    Method calculaKPIsQualidade(dDataIni, dDataFim, cProduto, cFornecedor)
        Local cQuery, aDados, aKPIs, nTotalEnsaios, nAprovados, nReprovados
        Local nTaxaConformidade, nCustoQualidade, nIndiceCapacidade
        
        cQuery := "SELECT COUNT(*) AS TOTAL, " +;
                 "SUM(CASE WHEN QAD_RLAUDO IN ('1','3') THEN 1 ELSE 0 END) AS APROVADOS, " +;
                 "SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) AS REPROVADOS " +;
                 "FROM QAD010 WHERE D_E_L_E_T_ = '' " +;
                 "AND QAD_DTENTR BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "'"
        
        If !Empty(cProduto)
            cQuery += " AND QAD_PRODUT = '" + cProduto + "'"
        EndIf
        
        If !Empty(cFornecedor)
            cQuery += " AND QAD_FORNEC = '" + cFornecedor + "'"
        EndIf
        
        aDados := This:executarQuery(cQuery)
        
        If !Empty(aDados)
            nTotalEnsaios := aDados[1]["TOTAL"]
            nAprovados := aDados[1]["APROVADOS"]
            nReprovados := aDados[1]["REPROVADOS"]
            nTaxaConformidade := Iif(nTotalEnsaios > 0, Round((nAprovados/nTotalEnsaios)*100, 2), 0)
        Else
            nTotalEnsaios := 0
            nAprovados := 0
            nReprovados := 0
            nTaxaConformidade := 0
        EndIf
        
        nCustoQualidade := This:calcularCustoQualidade(dDataIni, dDataFim)
        nIndiceCapacidade := This:calcularIndiceCapacidade(dDataIni, dDataFim)
        
        aKPIs := {;
            "totalEnsaios" => nTotalEnsaios,;
            "ensaiosAprovados" => nAprovados,;
            "ensaiosReprovados" => nReprovados,;
            "taxaConformidade" => nTaxaConformidade,;
            "custoQualidade" => nCustoQualidade,;
            "indiceCapacidade" => nIndiceCapacidade,;
            "status" => Iif(nTaxaConformidade >= 95, "EXCELENTE", Iif(nTaxaConformidade >= 90, "BOM", "CRITICO"));
        }
        
        Return aKPIs

    /*
     * Identifica produtos com maior risco de qualidade
     */
    Method identificaProdutosCriticos(dDataIni, dDataFim)
        Local cQuery, aDados, aProdutos, nI, oProduto
        
        cQuery := "SELECT QAD_PRODUT, B1_DESC, COUNT(*) AS TOTAL_ENSAIOS, " +;
                 "SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) AS NAO_CONFORMES, " +;
                 "ROUND((SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)), 2) AS TAXA_NC " +;
                 "FROM QAD010 QAD " +;
                 "INNER JOIN SB1010 SB1 ON QAD_PRODUT = B1_COD AND SB1.D_E_L_E_T_ = '' " +;
                 "WHERE QAD.D_E_L_E_T_ = '' " +;
                 "AND QAD_DTENTR BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                 "GROUP BY QAD_PRODUT, B1_DESC " +;
                 "HAVING COUNT(*) >= 5 AND (SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)) > 5 " +;
                 "ORDER BY TAXA_NC DESC"
        
        aDados := This:executarQuery(cQuery)
        aProdutos := {}
        
        For nI := 1 To Len(aDados)
            oProduto := {;
                "codigo" => aDados[nI]["QAD_PRODUT"],;
                "descricao" => aDados[nI]["B1_DESC"],;
                "totalEnsaios" => aDados[nI]["TOTAL_ENSAIOS"],;
                "naoConformes" => aDados[nI]["NAO_CONFORMES"],;
                "taxaNC" => aDados[nI]["TAXA_NC"],;
                "risco" => Iif(aDados[nI]["TAXA_NC"] > 15, "ALTO", Iif(aDados[nI]["TAXA_NC"] > 10, "MEDIO", "BAIXO"));
            }
            aAdd(aProdutos, oProduto)
        Next
        
        Return aProdutos

    /*
     * Analisa fornecedores com risco de qualidade
     */
    Method analisaFornecedoresRisco(dDataIni, dDataFim)
        Local cQuery, aDados, aFornecedores, nI, oFornecedor
        
        cQuery := "SELECT QAD_FORNEC, QAD_LOJFOR, A2_NOME, COUNT(*) AS TOTAL_ENSAIOS, " +;
                 "SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) AS NAO_CONFORMES, " +;
                 "ROUND((SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)), 2) AS TAXA_NC " +;
                 "FROM QAD010 QAD " +;
                 "INNER JOIN SA2010 SA2 ON QAD_FORNEC = A2_COD AND QAD_LOJFOR = A2_LOJA AND SA2.D_E_L_E_T_ = '' " +;
                 "WHERE QAD.D_E_L_E_T_ = '' " +;
                 "AND QAD_DTENTR BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                 "GROUP BY QAD_FORNEC, QAD_LOJFOR, A2_NOME " +;
                 "HAVING COUNT(*) >= 3 " +;
                 "ORDER BY TAXA_NC DESC"
        
        aDados := This:executarQuery(cQuery)
        aFornecedores := {}
        
        For nI := 1 To Len(aDados)
            oFornecedor := {;
                "codigo" => aDados[nI]["QAD_FORNEC"],;
                "loja" => aDados[nI]["QAD_LOJFOR"],;
                "nome" => aDados[nI]["A2_NOME"],;
                "totalEnsaios" => aDados[nI]["TOTAL_ENSAIOS"],;
                "naoConformes" => aDados[nI]["NAO_CONFORMES"],;
                "taxaNC" => aDados[nI]["TAXA_NC"],;
                "classificacao" => This:classificarFornecedor(aDados[nI]["TAXA_NC"]);
            }
            aAdd(aFornecedores, oFornecedor)
        Next
        
        Return aFornecedores

    /*
     * Executa query SQL e retorna resultado
     */
    Method executarQuery(cQuery)
        Local aDados
        
        // Em ambiente real, executaria a query
        // aDados := QuerySql(cQuery)
        
        // Para simulação, retorna dados fictícios
        aDados := {}
        
        Return aDados

    /*
     * Registra log das operações de qualidade
     */
    Method registraLogQualidade(cAcao, cUsuario, oParametros, lSucesso)
        Local oLog, file, fs, all
        
        oLog := {;
            "acao" => cAcao,;
            "usuario" => cUsuario,;
            "parametros" => oParametros,;
            "sucesso" => lSucesso,;
            "dataHora" => DToS(Date()) + " " + Time();
        }
        
        file := "./logs_qualidade.json"
        all := {}
        
        If File(file)
            fs := MemoRead(file)
            all := JsonDecode(fs)
        EndIf
        
        aAdd(all, oLog)
        MemoWrite(file, JsonEncode(all))
        
        Return .T.

    // =====================================================================
    // PARTE 3: RASTREABILIDADE COMPLETA E CALIBRAÇÃO DE EQUIPAMENTOS
    // =====================================================================

    /*
     * Sistema completo de rastreabilidade de lotes
     * Permite rastrear origem e destino de qualquer lote na cadeia produtiva
     */
    @Get("/qualidade/rastreabilidade/:lote")
    action rastreabilidadeLote(params)
        Local cLote, cProduto, cDirecao, oRastreamento, aOrigens, aDestinos
        Local aArvoreCompleta, lErro, cErro
        
        cLote := AllTrim(params["lote"])
        cProduto := Iif(params["produto"] != Nil, AllTrim(params["produto"]), "")
        cDirecao := Iif(params["direcao"] != Nil, AllTrim(params["direcao"]), "COMPLETA") // ORIGEM, DESTINO, COMPLETA
        
        lErro := .F.
        cErro := ""
        
        If Empty(cLote)
            Return { "sucesso" => .F., "erro" => "Número do lote é obrigatório" }
        EndIf
        
        Begin Sequence
            // Rastreamento para trás (origens)
            If cDirecao $ "ORIGEM|COMPLETA"
                aOrigens := This:rastrearOrigens(cLote, cProduto)
            Else
                aOrigens := {}
            EndIf
            
            // Rastreamento para frente (destinos)
            If cDirecao $ "DESTINO|COMPLETA"
                aDestinos := This:rastrearDestinos(cLote, cProduto)
            Else
                aDestinos := {}
            EndIf
            
            // Monta árvore completa de rastreamento
            aArvoreCompleta := This:montarArvoreRastreamento(cLote, cProduto, aOrigens, aDestinos)
            
            oRastreamento := {;
                "lote" => cLote,;
                "produto" => cProduto,;
                "direcaoConsulta" => cDirecao,;
                "dataConsulta" => DToS(Date()) + " " + Time(),;
                "origens" => aOrigens,;
                "destinos" => aDestinos,;
                "arvoreCompleta" => aArvoreCompleta,;
                "totalNiveis" => This:calcularNiveisRastreamento(aArvoreCompleta),;
                "conformidade" => This:verificarConformidadeRastreamento(aArvoreCompleta);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na rastreabilidade: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("rastreabilidadeLote", "SISTEMA", {"lote" => cLote, "direcao" => cDirecao}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "rastreamento" => oRastreamento }

    /*
     * Sistema de calibração de instrumentos e equipamentos
     * Controla agenda, histórico e status de calibração
     */
    @Get("/qualidade/calibracoes")
    action gerenciarCalibracoes(params)
        Local cStatus, dDataIni, dDataFim, cInstrumento, aCalibracoes, aCalibracoesPendentes
        Local aCalibracaoVencidas, aCalibracaoProximas, lErro, cErro
        
        cStatus := Iif(params["status"] != Nil, AllTrim(params["status"]), "TODOS")
        dDataIni := Iif(!Empty(params["dataInicio"]), SToD(StrTran(params["dataInicio"], "-", "")), Date() - 30)
        dDataFim := Iif(!Empty(params["dataFim"]), SToD(StrTran(params["dataFim"], "-", "")), Date() + 60)
        cInstrumento := Iif(params["instrumento"] != Nil, AllTrim(params["instrumento"]), "")
        
        lErro := .F.
        cErro := ""
        aCalibracoes := {}
        
        Begin Sequence
            // Busca calibrações no período
            aCalibracoes := This:buscarCalibracoes(dDataIni, dDataFim, cInstrumento, cStatus)
            
            // Identifica calibrações vencidas
            aCalibracaoVencidas := This:identificarCalibracaoVencidas()
            
            // Identifica calibrações próximas do vencimento
            aCalibracaoProximas := This:identificarCalibracaoProximas(30) // 30 dias
            
            // Calibrações pendentes de execução
            aCalibracoesPendentes := This:identificarCalibracoesPendentes()
            
            // Atualiza status automático baseado nas datas
            This:atualizarStatusCalibracoes(aCalibracoes)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no gerenciamento de calibrações: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("gerenciarCalibracoes", "SISTEMA", {"periodo" => DToS(dDataIni) + "-" + DToS(dDataFim)}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "calibracoes" => aCalibracoes, "vencidas" => aCalibracaoVencidas, "proximas" => aCalibracaoProximas, "pendentes" => aCalibracoesPendentes }

    /*
     * Programador automático de calibrações baseado em criticidade e uso
     * Otimiza agenda de calibrações considerando múltiplos fatores
     */
    @Post("/qualidade/programar-calibracoes")
    action programarCalibracoes(body)
        Local nPeriodoPrograma, cCriticidade, aProgramacao, aInstrumentos, nI, oInstrumento
        Local dProximaCalibra, nFrequenciaOtima, cJustificativa, lErro, cErro
        
        nPeriodoPrograma := Iif(body["periodoPrograma"] != Nil, body["periodoPrograma"], 365) // dias
        cCriticidade := Iif(body["criticidade"] != Nil, AllTrim(body["criticidade"]), "TODAS")
        
        lErro := .F.
        cErro := ""
        aProgramacao := {}
        
        Begin Sequence
            // Busca instrumentos que precisam de programação
            aInstrumentos := This:buscarInstrumentosAtivos(cCriticidade)
            
            For nI := 1 To Len(aInstrumentos)
                oInstrumento := aInstrumentos[nI]
                
                // Calcula frequência ótima baseada em uso e histórico
                nFrequenciaOtima := This:calcularFrequenciaOtima(oInstrumento["codigo"], oInstrumento["criticidade"])
                
                // Calcula próxima data de calibração
                dProximaCalibra := This:calcularProximaCalibra(oInstrumento["ultimaCalibra"], nFrequenciaOtima)
                
                // Gera justificativa da programação
                cJustificativa := This:gerarJustificativaCalibra(oInstrumento, nFrequenciaOtima)
                
                // Verifica disponibilidade na agenda
                If This:verificarDisponibilidadeAgenda(dProximaCalibra)
                    oInstrumento["proximaCalibra"] := dProximaCalibra
                    oInstrumento["status"] := "PROGRAMADA"
                Else
                    // Busca próxima data disponível
                    dProximaCalibra := This:buscarProximaDataDisponivel(dProximaCalibra)
                    oInstrumento["proximaCalibra"] := dProximaCalibra
                    oInstrumento["status"] := "REPROGRAMADA"
                EndIf
                
                oInstrumento["frequenciaOtima"] := nFrequenciaOtima
                oInstrumento["justificativa"] := cJustificativa
                
                // Registra programação no sistema
                This:registrarProgramacaoCalibra(oInstrumento)
                
                aAdd(aProgramacao, oInstrumento)
            Next
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na programação de calibrações: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("programarCalibracoes", "SISTEMA", {"periodo" => nPeriodoPrograma, "criticidade" => cCriticidade}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "programacao" => aProgramacao, "totalInstrumentos" => Len(aProgramacao) }

    /*
     * Executar calibração e registrar resultados
     * Permite registrar calibração realizada com resultados e certificados
     */
    @Post("/qualidade/executar-calibracao")
    action executarCalibracao(body)
        Local cInstrumento, dDataCalibra, cResponsavel, cLaboratorio, aCertificados
        Local aResultados, cObservacoes, oCalibra, lAprovado, dProximaCalibra, lErro, cErro
        
        cInstrumento := AllTrim(body["instrumento"])
        dDataCalibra := SToD(StrTran(body["dataCalibra"], "-", ""))
        cResponsavel := AllTrim(body["responsavel"])
        cLaboratorio := Iif(body["laboratorio"] != Nil, AllTrim(body["laboratorio"]), "")
        aCertificados := Iif(body["certificados"] != Nil, body["certificados"], {})
        aResultados := Iif(body["resultados"] != Nil, body["resultados"], {})
        cObservacoes := Iif(body["observacoes"] != Nil, body["observacoes"], "")
        
        lErro := .F.
        cErro := ""
        
        If Empty(cInstrumento) .Or. Empty(dDataCalibra) .Or. Empty(cResponsavel)
            Return { "sucesso" => .F., "erro" => "Instrumento, data e responsável são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Valida se instrumento existe e está ativo
            If !This:validarInstrumentoAtivo(cInstrumento)
                Return { "sucesso" => .F., "erro" => "Instrumento não encontrado ou inativo" }
            EndIf
            
            // Analisa resultados da calibração
            lAprovado := This:analisarResultadosCalibra(aResultados)
            
            // Calcula próxima calibração baseada no resultado
            dProximaCalibra := This:calcularProximaCalibracaoPorResultado(dDataCalibra, lAprovado, cInstrumento)
            
            oCalibra := {;
                "instrumento" => cInstrumento,;
                "dataCalibra" => DToS(dDataCalibra),;
                "responsavel" => cResponsavel,;
                "laboratorio" => cLaboratorio,;
                "aprovado" => lAprovado,;
                "resultados" => aResultados,;
                "certificados" => aCertificados,;
                "observacoes" => cObservacoes,;
                "proximaCalibra" => DToS(dProximaCalibra),;
                "dataRegistro" => DToS(Date()),;
                "horaRegistro" => Time();
            }
            
            // Registra calibração executada
            This:registrarCalibraExecutada(oCalibra)
            
            // Atualiza status do instrumento
            This:atualizarStatusInstrumento(cInstrumento, lAprovado, dDataCalibra, dProximaCalibra)
            
            // Gera alertas se reprovado
            If !lAprovado
                This:gerarAlertaInstrumentoReprovado(cInstrumento, aResultados)
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na execução da calibração: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("executarCalibracao", cResponsavel, {"instrumento" => cInstrumento, "aprovado" => lAprovado}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "calibracao" => oCalibra, "proximaCalibra" => DToS(dProximaCalibra) }

    /*
     * Dashboard de controle de instrumentos
     * Visão executiva do status de calibração dos instrumentos
     */
    @Get("/qualidade/dashboard-instrumentos")
    action dashboardInstrumentos(params)
        Local cDepartamento, cCriticidade, oDashboard, aKPIs, aInstrumentosStatus
        Local aTop10Criticos, aHistoricoMensal, lErro, cErro
        
        cDepartamento := Iif(params["departamento"] != Nil, AllTrim(params["departamento"]), "")
        cCriticidade := Iif(params["criticidade"] != Nil, AllTrim(params["criticidade"]), "")
        
        lErro := .F.
        cErro := ""
        
        Begin Sequence
            // KPIs principais de instrumentos
            aKPIs := This:calcularKPIsInstrumentos(cDepartamento, cCriticidade)
            
            // Status atual dos instrumentos
            aInstrumentosStatus := This:obterStatusInstrumentos(cDepartamento, cCriticidade)
            
            // Top 10 instrumentos críticos
            aTop10Criticos := This:identificarInstrumentosCriticos(10)
            
            // Histórico mensal de calibrações
            aHistoricoMensal := This:obterHistoricoMensalCalibra(12) // 12 meses
            
            oDashboard := {;
                "dataAtualizacao" => DToS(Date()) + " " + Time(),;
                "filtros" => {;
                    "departamento" => cDepartamento,;
                    "criticidade" => cCriticidade;
                },;
                "kpis" => aKPIs,;
                "statusInstrumentos" => aInstrumentosStatus,;
                "instrumentosCriticos" => aTop10Criticos,;
                "historicoMensal" => aHistoricoMensal,;
                "alertas" => This:gerarAlertasInstrumentos();
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no dashboard de instrumentos: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("dashboardInstrumentos", "SISTEMA", {"departamento" => cDepartamento}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "dashboard" => oDashboard }

    // =====================================================================
    // MÉTODOS AUXILIARES - PARTE 3
    // =====================================================================
    
    /*
     * Rastreia origens de um lote (backward tracking)
     */
    Method rastrearOrigens(cLote, cProduto)
        Local cQuery, aDados, aOrigens, nI, oOrigem, aSubOrigens
        
        // Busca componentes que originaram o lote
        cQuery := "SELECT DISTINCT D4_COD AS PRODUTO_ORIGEM, D4_LOTECTL AS LOTE_ORIGEM, " +;
                 "D4_OP AS OP, B1_DESC AS DESCRICAO FROM SD4010 D4 " +;
                 "INNER JOIN SC2010 C2 ON D4_OP = C2_NUM+C2_ITEM+C2_SEQUEN AND C2.D_E_L_E_T_ = '' " +;
                 "INNER JOIN SB1010 B1 ON D4_COD = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                 "WHERE D4.D_E_L_E_T_ = '' " +;
                 "AND EXISTS (SELECT 1 FROM SC2010 WHERE C2_NUM+C2_ITEM+C2_SEQUEN = D4_OP " +;
                 "AND C2_PRODUTO = '" + cProduto + "' AND C2_LOTECTL = '" + cLote + "' AND D_E_L_E_T_ = '')"
        
        aDados := This:executarQuery(cQuery)
        aOrigens := {}
        
        For nI := 1 To Len(aDados)
            // Busca sub-origens recursivamente
            aSubOrigens := This:rastrearOrigens(aDados[nI]["LOTE_ORIGEM"], aDados[nI]["PRODUTO_ORIGEM"])
            
            oOrigem := {;
                "nivel" => 1,;
                "produtoOrigem" => aDados[nI]["PRODUTO_ORIGEM"],;
                "loteOrigem" => aDados[nI]["LOTE_ORIGEM"],;
                "descricao" => aDados[nI]["DESCRICAO"],;
                "op" => aDados[nI]["OP"],;
                "subOrigens" => aSubOrigens;
            }
            
            aAdd(aOrigens, oOrigem)
        Next
        
        Return aOrigens

    /*
     * Rastreia destinos de um lote (forward tracking)
     */
    Method rastrearDestinos(cLote, cProduto)
        Local cQuery, aDados, aDestinos, nI, oDestino, aSubDestinos
        
        // Busca onde o lote foi utilizado
        cQuery := "SELECT DISTINCT C2_PRODUTO AS PRODUTO_DESTINO, C2_LOTECTL AS LOTE_DESTINO, " +;
                 "C2_NUM AS OP, B1_DESC AS DESCRICAO FROM SC2010 C2 " +;
                 "INNER JOIN SD4010 D4 ON C2_NUM+C2_ITEM+C2_SEQUEN = D4_OP AND D4.D_E_L_E_T_ = '' " +;
                 "INNER JOIN SB1010 B1 ON C2_PRODUTO = B1_COD AND B1.D_E_L_E_T_ = '' " +;
                 "WHERE C2.D_E_L_E_T_ = '' " +;
                 "AND D4_COD = '" + cProduto + "' AND D4_LOTECTL = '" + cLote + "'"
        
        aDados := This:executarQuery(cQuery)
        aDestinos := {}
        
        For nI := 1 To Len(aDados)
            // Busca sub-destinos recursivamente
            aSubDestinos := This:rastrearDestinos(aDados[nI]["LOTE_DESTINO"], aDados[nI]["PRODUTO_DESTINO"])
            
            oDestino := {;
                "nivel" => 1,;
                "produtoDestino" => aDados[nI]["PRODUTO_DESTINO"],;
                "loteDestino" => aDados[nI]["LOTE_DESTINO"],;
                "descricao" => aDados[nI]["DESCRICAO"],;
                "op" => aDados[nI]["OP"],;
                "subDestinos" => aSubDestinos;
            }
            
            aAdd(aDestinos, oDestino)
        Next
        
        Return aDestinos

    /*
     * Busca calibrações no período especificado
     */
    Method buscarCalibracoes(dDataIni, dDataFim, cInstrumento, cStatus)
        Local cQuery, aDados, aCalibracoes, nI, oCalibra
        
        cQuery := "SELECT QM1_INSTRU, QM1_DESC, QM1_PERIOD, QM1_ULTCAL, QM1_PROXCA, " +;
                 "QM1_STATUS, QM1_DEPTO, QM1_RESPONS FROM QM1010 " +;
                 "WHERE D_E_L_E_T_ = '' " +;
                 "AND QM1_PROXCA BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "'"
        
        If !Empty(cInstrumento)
            cQuery += " AND QM1_INSTRU = '" + cInstrumento + "'"
        EndIf
        
        If !Empty(cStatus) .And. cStatus != "TODOS"
            cQuery += " AND QM1_STATUS = '" + cStatus + "'"
        EndIf
        
        aDados := This:executarQuery(cQuery)
        aCalibracoes := {}
        
        For nI := 1 To Len(aDados)
            oCalibra := {;
                "instrumento" => aDados[nI]["QM1_INSTRU"],;
                "descricao" => aDados[nI]["QM1_DESC"],;
                "periodicidade" => aDados[nI]["QM1_PERIOD"],;
                "ultimaCalibra" => aDados[nI]["QM1_ULTCAL"],;
                "proximaCalibra" => aDados[nI]["QM1_PROXCA"],;
                "status" => aDados[nI]["QM1_STATUS"],;
                "departamento" => aDados[nI]["QM1_DEPTO"],;
                "responsavel" => aDados[nI]["QM1_RESPONS"],;
                "diasVencimento" => SToD(aDados[nI]["QM1_PROXCA"]) - Date();
            }
            
            aAdd(aCalibracoes, oCalibra)
        Next
        
        Return aCalibracoes

    /*
     * Calcula frequência ótima de calibração baseada em uso e criticidade
     */
    Method calcularFrequenciaOtima(cInstrumento, cCriticidade)
        Local nFrequenciaAtual, nFrequenciaUso, nFrequenciaOtima, nFatorCriticidade
        
        // Busca frequência atual
        nFrequenciaAtual := This:obterFrequenciaAtual(cInstrumento)
        
        // Calcula frequência baseada no uso
        nFrequenciaUso := This:calcularFrequenciaPorUso(cInstrumento)
        
        // Fator de criticidade
        If cCriticidade == "ALTA"
            nFatorCriticidade := 0.8  // Reduz 20% do período
        ElseIf cCriticidade == "MEDIA"
            nFatorCriticidade := 1.0  // Mantém período
        Else
            nFatorCriticidade := 1.2  // Aumenta 20% do período
        EndIf
        
        // Calcula frequência ótima
        nFrequenciaOtima := Round((nFrequenciaAtual + nFrequenciaUso) / 2 * nFatorCriticidade, 0)
        
        // Limites mínimo e máximo
        nFrequenciaOtima := Max(30, Min(365, nFrequenciaOtima))
        
        Return nFrequenciaOtima

    /*
     * Calcula KPIs de instrumentos
     */
    Method calcularKPIsInstrumentos(cDepartamento, cCriticidade)
        Local cQuery, aDados, aKPIs, nTotal, nVencidos, nProximos, nAprovados
        
        cQuery := "SELECT COUNT(*) AS TOTAL, " +;
                 "SUM(CASE WHEN QM1_PROXCA < '" + DToS(Date()) + "' THEN 1 ELSE 0 END) AS VENCIDOS, " +;
                 "SUM(CASE WHEN QM1_PROXCA BETWEEN '" + DToS(Date()) + "' AND '" + DToS(Date()+30) + "' THEN 1 ELSE 0 END) AS PROXIMOS, " +;
                 "SUM(CASE WHEN QM1_STATUS = 'A' THEN 1 ELSE 0 END) AS APROVADOS " +;
                 "FROM QM1010 WHERE D_E_L_E_T_ = ''"
        
        If !Empty(cDepartamento)
            cQuery += " AND QM1_DEPTO = '" + cDepartamento + "'"
        EndIf
        
        aDados := This:executarQuery(cQuery)
        
        If !Empty(aDados)
            nTotal := aDados[1]["TOTAL"]
            nVencidos := aDados[1]["VENCIDOS"]
            nProximos := aDados[1]["PROXIMOS"]
            nAprovados := aDados[1]["APROVADOS"]
        Else
            nTotal := 0
            nVencidos := 0
            nProximos := 0
            nAprovados := 0
        EndIf
        
        aKPIs := {;
            "totalInstrumentos" => nTotal,;
            "calibracaoVencida" => nVencidos,;
            "calibracaoProxima" => nProximos,;
            "instrumentosAprovados" => nAprovados,;
            "percentualConformidade" => Iif(nTotal > 0, Round(((nTotal - nVencidos) / nTotal) * 100, 2), 100),;
            "status" => Iif(nVencidos == 0, "CONFORME", Iif(nVencidos <= (nTotal * 0.05), "ATENCAO", "CRITICO"));
        }
        
        Return aKPIs

    /*
     * Monta árvore completa de rastreamento
     */
    Method montarArvoreRastreamento(cLote, cProduto, aOrigens, aDestinos)
        Local aArvore, oNo
        
        oNo := {;
            "lote" => cLote,;
            "produto" => cProduto,;
            "nivel" => 0,;
            "tipo" => "PRINCIPAL",;
            "origens" => aOrigens,;
            "destinos" => aDestinos;
        }
        
        aArvore := { oNo }
        
        Return aArvore

    // =====================================================================
    // PARTE 4: AUDITORIAS AUTOMÁTICAS E RELATÓRIOS AVANÇADOS
    // =====================================================================

    /*
     * Sistema de auditorias automáticas baseado em checklist configurável
     * Executa auditorias periódicas e gera relatórios de conformidade
     */
    @Post("/qualidade/executar-auditoria")
    action executarAuditoria(body)
        Local cTipoAuditoria, aDepartamentos, cResponsavel, aChecklists, oAuditoria
        Local nI, oItem, nPontuacao, nConformidade, aResultados, aAcoesCorretivas, lErro, cErro
        
        cTipoAuditoria := AllTrim(body["tipoAuditoria"]) // ISO9001, ISO14001, INTERNA, etc.
        aDepartamentos := Iif(body["departamentos"] != Nil, body["departamentos"], {})
        cResponsavel := AllTrim(body["responsavel"])
        aChecklists := Iif(body["checklists"] != Nil, body["checklists"], {})
        
        lErro := .F.
        cErro := ""
        aResultados := {}
        aAcoesCorretivas := {}
        
        If Empty(cTipoAuditoria) .Or. Empty(cResponsavel)
            Return { "sucesso" => .F., "erro" => "Tipo de auditoria e responsável são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Se não especificou checklist, busca padrão do tipo
            If Empty(aChecklists)
                aChecklists := This:buscarChecklistPadrao(cTipoAuditoria)
            EndIf
            
            // Se não especificou departamentos, audita todos
            If Empty(aDepartamentos)
                aDepartamentos := This:buscarDepartamentosAtivos()
            EndIf
            
            nPontuacao := 0
            
            // Executa cada item do checklist
            For nI := 1 To Len(aChecklists)
                oItem := aChecklists[nI]
                
                // Executa verificação automática se aplicável
                If oItem["automatico"] == .T.
                    oItem["resultado"] := This:executarVerificacaoAutomatica(oItem["codigo"], aDepartamentos)
                    oItem["evidencia"] := oItem["resultado"]["evidencia"]
                    oItem["observacoes"] := oItem["resultado"]["observacoes"]
                Else
                    // Para itens manuais, mantém o resultado informado
                    If oItem["resultado"] == Nil
                        oItem["resultado"] := { "conforme" => .F., "evidencia" => "", "observacoes" => "Verificação manual pendente" }
                    EndIf
                EndIf
                
                // Calcula pontuação
                If oItem["resultado"]["conforme"] == .T.
                    nPontuacao += oItem["peso"]
                Else
                    // Gera ação corretiva se não conforme
                    aAdd(aAcoesCorretivas, This:gerarAcaoCorretiva(oItem, aDepartamentos))
                EndIf
                
                aAdd(aResultados, oItem)
            Next
            
            // Calcula percentual de conformidade
            nConformidade := Round((nPontuacao / This:calcularPontuacaoMaxima(aChecklists)) * 100, 2)
            
            oAuditoria := {;
                "codigo" => This:gerarCodigoAuditoria(cTipoAuditoria),;
                "tipoAuditoria" => cTipoAuditoria,;
                "departamentos" => aDepartamentos,;
                "responsavel" => cResponsavel,;
                "dataExecucao" => DToS(Date()),;
                "horaExecucao" => Time(),;
                "resultados" => aResultados,;
                "pontuacaoTotal" => nPontuacao,;
                "percentualConformidade" => nConformidade,;
                "acoesCorretivas" => aAcoesCorretivas,;
                "status" => Iif(nConformidade >= 95, "EXCELENTE", Iif(nConformidade >= 85, "CONFORME", "NAO_CONFORME"));
            }
            
            // Registra auditoria no sistema
            This:registrarAuditoria(oAuditoria)
            
            // Programa próxima auditoria automaticamente
            This:programarProximaAuditoria(cTipoAuditoria, oAuditoria["status"])
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na execução da auditoria: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("executarAuditoria", cResponsavel, {"tipo" => cTipoAuditoria, "conformidade" => nConformidade}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "auditoria" => oAuditoria }

    /*
     * Gerador de relatórios gerenciais avançados de qualidade
     * Relatórios executivos com análises estatísticas e gráficos
     */
    @Post("/qualidade/relatorio-gerencial")
    action relatorioGerencial(body)
        Local cTipoRelatorio, dDataIni, dDataFim, aFiltros, oRelatorio, aDados
        Local aAnalisesEstatisticas, aGraficos, aRecomendacoes, cFormato, lErro, cErro
        
        cTipoRelatorio := AllTrim(body["tipoRelatorio"]) // PRODUTIVIDADE, FORNECEDORES, CUSTOS, etc.
        dDataIni := SToD(StrTran(body["dataInicio"], "-", ""))
        dDataFim := SToD(StrTran(body["dataFim"], "-", ""))
        aFiltros := Iif(body["filtros"] != Nil, body["filtros"], {})
        cFormato := Iif(body["formato"] != Nil, AllTrim(body["formato"]), "JSON") // JSON, PDF, EXCEL
        
        lErro := .F.
        cErro := ""
        
        If Empty(cTipoRelatorio) .Or. Empty(dDataIni) .Or. Empty(dDataFim)
            Return { "sucesso" => .F., "erro" => "Tipo de relatório e período são obrigatórios" }
        EndIf
        
        If dDataFim < dDataIni
            Return { "sucesso" => .F., "erro" => "Data fim deve ser maior que data início" }
        EndIf
        
        Begin Sequence
            // Coleta dados baseado no tipo de relatório
            aDados := This:coletarDadosRelatorio(cTipoRelatorio, dDataIni, dDataFim, aFiltros)
            
            If Empty(aDados)
                Return { "sucesso" => .F., "erro" => "Nenhum dado encontrado para os filtros especificados" }
            EndIf
            
            // Gera análises estatísticas
            aAnalisesEstatisticas := This:gerarAnalisesEstatisticas(aDados, cTipoRelatorio)
            
            // Gera dados para gráficos
            aGraficos := This:gerarDadosGraficos(aDados, cTipoRelatorio)
            
            // Gera recomendações baseadas nos dados
            aRecomendacoes := This:gerarRecomendacoesRelatorio(aAnalisesEstatisticas, cTipoRelatorio)
            
            oRelatorio := {;
                "codigo" => This:gerarCodigoRelatorio(cTipoRelatorio),;
                "tipoRelatorio" => cTipoRelatorio,;
                "periodo" => {;
                    "dataInicio" => DToS(dDataIni),;
                    "dataFim" => DToS(dDataFim);
                },;
                "filtros" => aFiltros,;
                "formato" => cFormato,;
                "dataGeracao" => DToS(Date()),;
                "horaGeracao" => Time(),;
                "dados" => aDados,;
                "analisesEstatisticas" => aAnalisesEstatisticas,;
                "graficos" => aGraficos,;
                "recomendacoes" => aRecomendacoes,;
                "resumoExecutivo" => This:gerarResumoExecutivo(aAnalisesEstatisticas, aRecomendacoes);
            }
            
            // Gera arquivo se formato diferente de JSON
            If cFormato != "JSON"
                oRelatorio["nomeArquivo"] := This:exportarRelatorio(oRelatorio, cFormato)
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na geração do relatório: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("relatorioGerencial", "SISTEMA", {"tipo" => cTipoRelatorio, "periodo" => DToS(dDataIni) + "-" + DToS(dDataFim)}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "relatorio" => oRelatorio }

    /*
     * Sistema de acompanhamento de ações corretivas e preventivas
     * Gerencia CAPA (Corrective and Preventive Actions) completo
     */
    @Post("/qualidade/acao-corretiva")
    action gerenciarAcaoCorretiva(body)
        Local cTipoAcao, cOrigem, cDescricaoProblema, cCausaRaiz, aAcoesImediatas
        Local aAcoesCorretivas, cResponsavel, dPrazo, oAcao, cCodigo, lErro, cErro
        
        cTipoAcao := AllTrim(body["tipoAcao"]) // CORRETIVA, PREVENTIVA
        cOrigem := AllTrim(body["origem"]) // AUDITORIA, NAO_CONFORMIDADE, RECLAMACAO
        cDescricaoProblema := body["descricaoProblema"]
        cCausaRaiz := body["causaRaiz"]
        aAcoesImediatas := Iif(body["acoesImediatas"] != Nil, body["acoesImediatas"], {})
        aAcoesCorretivas := Iif(body["acoesCorretivas"] != Nil, body["acoesCorretivas"], {})
        cResponsavel := AllTrim(body["responsavel"])
        dPrazo := SToD(StrTran(body["prazo"], "-", ""))
        
        lErro := .F.
        cErro := ""
        
        If Empty(cTipoAcao) .Or. Empty(cOrigem) .Or. Empty(cDescricaoProblema) .Or. Empty(cResponsavel)
            Return { "sucesso" => .F., "erro" => "Tipo, origem, descrição e responsável são obrigatórios" }
        EndIf
        
        Begin Sequence
            cCodigo := This:gerarCodigoAcaoCorretiva(cTipoAcao)
            
            oAcao := {;
                "codigo" => cCodigo,;
                "tipoAcao" => cTipoAcao,;
                "origem" => cOrigem,;
                "descricaoProblema" => cDescricaoProblema,;
                "causaRaiz" => cCausaRaiz,;
                "acoesImediatas" => aAcoesImediatas,;
                "acoesCorretivas" => aAcoesCorretivas,;
                "responsavel" => cResponsavel,;
                "prazo" => DToS(dPrazo),;
                "dataAbertura" => DToS(Date()),;
                "horaAbertura" => Time(),;
                "status" => "ABERTA",;
                "eficacia" => "",;
                "dataFechamento" => "",;
                "historicoAlteracoes" => {};
            }
            
            // Registra ação no sistema
            This:registrarAcaoCorretiva(oAcao)
            
            // Envia notificação para responsável
            This:enviarNotificacaoAcaoCorretiva(oAcao)
            
            // Programa acompanhamento automático
            This:programarAcompanhamentoAcao(cCodigo, dPrazo)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no gerenciamento da ação corretiva: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("gerenciarAcaoCorretiva", cResponsavel, {"codigo" => cCodigo, "tipo" => cTipoAcao}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "acaoCorretiva" => oAcao, "codigo" => cCodigo }

    /*
     * Painel de indicadores de qualidade em tempo real
     * KPIs dinâmicos e alertas automáticos
     */
    @Get("/qualidade/indicadores-tempo-real")
    action indicadoresTempoReal(params)
        Local aPainelKPIs, aAlertas, aTendencias, aComparativos, oPainel, lErro, cErro
        
        lErro := .F.
        cErro := ""
        
        Begin Sequence
            // KPIs principais em tempo real
            aPainelKPIs := This:calcularKPIsTempoReal()
            
            // Alertas críticos ativos
            aAlertas := This:obterAlertasCriticosAtivos()
            
            // Tendências dos últimos 7 dias
            aTendencias := This:calcularTendenciasRecentes(7)
            
            // Comparativo com período anterior
            aComparativos := This:calcularComparativoPeriodos()
            
            oPainel := {;
                "dataAtualizacao" => DToS(Date()) + " " + Time(),;
                "kpis" => aPainelKPIs,;
                "alertasCriticos" => aAlertas,;
                "tendenciasRecentes" => aTendencias,;
                "comparativoPeriodos" => aComparativos,;
                "statusGeral" => This:calcularStatusGeral(aPainelKPIs, aAlertas);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro ao obter indicadores: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "painel" => oPainel }

    /*
     * Gerador de análise de capacidade de processo (Cp, Cpk)
     * Análise estatística avançada para controle de processos
     */
    @Post("/qualidade/analise-capacidade")
    action analiseCapacidadeProcesso(body)
        Local cProduto, cEnsaio, dDataIni, dDataFim, nLSE, nLIE, aDadosEnsaios
        Local oAnalise, nCp, nCpk, nPpk, nMedia, nDesvio, aHistograma, lErro, cErro
        
        cProduto := AllTrim(body["produto"])
        cEnsaio := AllTrim(body["ensaio"])
        dDataIni := SToD(StrTran(body["dataInicio"], "-", ""))
        dDataFim := SToD(StrTran(body["dataFim"], "-", ""))
        nLSE := body["limiteSuperior"] // Limite Superior de Especificação
        nLIE := body["limiteInferior"] // Limite Inferior de Especificação
        
        lErro := .F.
        cErro := ""
        
        If Empty(cProduto) .Or. Empty(cEnsaio) .Or. Empty(nLSE) .Or. Empty(nLIE)
            Return { "sucesso" => .F., "erro" => "Produto, ensaio e limites são obrigatórios" }
        EndIf
        
        If nLSE <= nLIE
            Return { "sucesso" => .F., "erro" => "Limite superior deve ser maior que limite inferior" }
        EndIf
        
        Begin Sequence
            // Coleta dados dos ensaios
            aDadosEnsaios := This:coletarDadosEnsaiosCapacidade(cProduto, cEnsaio, dDataIni, dDataFim)
            
            If Len(aDadosEnsaios) < 30
                Return { "sucesso" => .F., "erro" => "Mínimo de 30 medições necessárias para análise de capacidade" }
            EndIf
            
            // Calcula estatísticas básicas
            nMedia := This:calcularMedia(aDadosEnsaios)
            nDesvio := This:calcularDesvioPadrao(aDadosEnsaios)
            
            // Calcula índices de capacidade
            nCp := (nLSE - nLIE) / (6 * nDesvio)
            nCpk := Min((nLSE - nMedia) / (3 * nDesvio), (nMedia - nLIE) / (3 * nDesvio))
            nPpk := This:calcularPpk(aDadosEnsaios, nLSE, nLIE)
            
            // Gera histograma
            aHistograma := This:gerarHistograma(aDadosEnsaios, 10) // 10 classes
            
            oAnalise := {;
                "produto" => cProduto,;
                "ensaio" => cEnsaio,;
                "periodo" => DToS(dDataIni) + " a " + DToS(dDataFim),;
                "totalMedicoes" => Len(aDadosEnsaios),;
                "limiteSuperior" => nLSE,;
                "limiteInferior" => nLIE,;
                "media" => nMedia,;
                "desvioPadrao" => nDesvio,;
                "cp" => Round(nCp, 4),;
                "cpk" => Round(nCpk, 4),;
                "ppk" => Round(nPpk, 4),;
                "histograma" => aHistograma,;
                "interpretacao" => This:interpretarIndicesCapacidade(nCp, nCpk),;
                "recomendacoes" => This:gerarRecomendacoesCapacidade(nCp, nCpk, nPpk);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na análise de capacidade: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("analiseCapacidadeProcesso", "SISTEMA", {"produto" => cProduto, "ensaio" => cEnsaio}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "analiseCapacidade" => oAnalise }

    // =====================================================================
    // MÉTODOS AUXILIARES - PARTE 4
    // =====================================================================
    
    /*
     * Busca checklist padrão para tipo de auditoria
     */
    Method buscarChecklistPadrao(cTipoAuditoria)
        Local aChecklist
        
        If cTipoAuditoria == "ISO9001"
            aChecklist := {;
                { "codigo" => "ISO9001_01", "descricao" => "Política da Qualidade documentada e comunicada", "peso" => 10, "automatico" => .T. },;
                { "codigo" => "ISO9001_02", "descricao" => "Objetivos da Qualidade mensuráveis", "peso" => 10, "automatico" => .T. },;
                { "codigo" => "ISO9001_03", "descricao" => "Controle de documentos implementado", "peso" => 15, "automatico" => .T. },;
                { "codigo" => "ISO9001_04", "descricao" => "Registros da qualidade controlados", "peso" => 15, "automatico" => .T. },;
                { "codigo" => "ISO9001_05", "descricao" => "Análise crítica pela direção realizada", "peso" => 20, "automatico" => .F. },;
                { "codigo" => "ISO9001_06", "descricao" => "Ações corretivas implementadas", "peso" => 15, "automatico" => .T. },;
                { "codigo" => "ISO9001_07", "descricao" => "Auditorias internas realizadas conforme programa", "peso" => 15, "automatico" => .T. };
            }
        ElseIf cTipoAuditoria == "INTERNA"
            aChecklist := {;
                { "codigo" => "INT_01", "descricao" => "Calibração de instrumentos em dia", "peso" => 25, "automatico" => .T. },;
                { "codigo" => "INT_02", "descricao" => "Ensaios realizados conforme procedimentos", "peso" => 25, "automatico" => .T. },;
                { "codigo" => "INT_03", "descricao" => "Não conformidades tratadas adequadamente", "peso" => 25, "automatico" => .T. },;
                { "codigo" => "INT_04", "descricao" => "Treinamentos realizados conforme plano", "peso" => 25, "automatico" => .F. };
            }
        Else
            aChecklist := {}
        EndIf
        
        Return aChecklist

    /*
     * Executa verificação automática de item de auditoria
     */
    Method executarVerificacaoAutomatica(cCodigo, aDepartamentos)
        Local oResultado, cQuery, aDados, lConforme, cEvidencia, cObservacoes
        
        lConforme := .F.
        cEvidencia := ""
        cObservacoes := ""
        
        If cCodigo == "ISO9001_01" // Política da Qualidade
            // Verifica se existe documento de política
            cQuery := "SELECT COUNT(*) AS QTD FROM QDH010 WHERE D_E_L_E_T_ = '' AND QDH_TITULO LIKE '%POLITICA%QUALIDADE%'"
            aDados := This:executarQuery(cQuery)
            lConforme := !Empty(aDados) .And. aDados[1]["QTD"] > 0
            cEvidencia := Iif(lConforme, "Documento de Política encontrado", "Documento não encontrado")
            
        ElseIf cCodigo == "INT_01" // Calibração de instrumentos
            // Verifica instrumentos vencidos
            cQuery := "SELECT COUNT(*) AS VENCIDOS FROM QM1010 WHERE D_E_L_E_T_ = '' AND QM1_PROXCA < '" + DToS(Date()) + "'"
            aDados := This:executarQuery(cQuery)
            lConforme := !Empty(aDados) .And. aDados[1]["VENCIDOS"] == 0
            cEvidencia := Iif(lConforme, "Todos os instrumentos calibrados", cValToChar(aDados[1]["VENCIDOS"]) + " instrumentos vencidos")
            
        ElseIf cCodigo == "INT_02" // Ensaios conforme procedimentos
            // Verifica se todos os ensaios têm resultados
            cQuery := "SELECT COUNT(*) AS PENDENTES FROM QAD010 WHERE D_E_L_E_T_ = '' AND QAD_RESULT = '' AND QAD_DTENTR >= '" + DToS(Date()-30) + "'"
            aDados := This:executarQuery(cQuery)
            lConforme := !Empty(aDados) .And. aDados[1]["PENDENTES"] == 0
            cEvidencia := Iif(lConforme, "Todos os ensaios com resultados", cValToChar(aDados[1]["PENDENTES"]) + " ensaios pendentes")
            
        Else
            lConforme := .F.
            cEvidencia := "Verificação automática não implementada para este item"
        EndIf
        
        oResultado := {;
            "conforme" => lConforme,;
            "evidencia" => cEvidencia,;
            "observacoes" => cObservacoes;
        }
        
        Return oResultado

    /*
     * Coleta dados para relatórios baseado no tipo
     */
    Method coletarDadosRelatorio(cTipoRelatorio, dDataIni, dDataFim, aFiltros)
        Local cQuery, aDados
        
        If cTipoRelatorio == "PRODUTIVIDADE"
            cQuery := "SELECT QAD_PRODUT, COUNT(*) AS TOTAL_ENSAIOS, " +;
                     "SUM(CASE WHEN QAD_RLAUDO IN ('1','3') THEN 1 ELSE 0 END) AS APROVADOS, " +;
                     "ROUND(AVG(DATEDIFF(day, QAD_DTCOLE, QAD_DTENTR)), 2) AS TEMPO_MEDIO " +;
                     "FROM QAD010 WHERE D_E_L_E_T_ = '' " +;
                     "AND QAD_DTENTR BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                     "GROUP BY QAD_PRODUT ORDER BY TOTAL_ENSAIOS DESC"
                     
        ElseIf cTipoRelatorio == "FORNECEDORES"
            cQuery := "SELECT QAD_FORNEC, A2_NOME, COUNT(*) AS TOTAL_ENSAIOS, " +;
                     "SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) AS NAO_CONFORMES, " +;
                     "ROUND((SUM(CASE WHEN QAD_RLAUDO = '2' THEN 1 ELSE 0 END) * 100.0 / COUNT(*)), 2) AS TAXA_NC " +;
                     "FROM QAD010 QAD " +;
                     "INNER JOIN SA2010 SA2 ON QAD_FORNEC = A2_COD AND SA2.D_E_L_E_T_ = '' " +;
                     "WHERE QAD.D_E_L_E_T_ = '' " +;
                     "AND QAD_DTENTR BETWEEN '" + DToS(dDataIni) + "' AND '" + DToS(dDataFim) + "' " +;
                     "GROUP BY QAD_FORNEC, A2_NOME ORDER BY TAXA_NC DESC"
                     
        Else
            cQuery := ""
        EndIf
        
        aDados := This:executarQuery(cQuery)
        
        Return aDados

    /*
     * Calcula média de array de valores
     */
    Method calcularMedia(aValores)
        Local nSoma, nI, nMedia
        
        nSoma := 0
        For nI := 1 To Len(aValores)
            nSoma += aValores[nI]
        Next
        
        nMedia := Iif(Len(aValores) > 0, nSoma / Len(aValores), 0)
        
        Return nMedia

    /*
     * Calcula desvio padrão de array de valores
     */
    Method calcularDesvioPadrao(aValores)
        Local nMedia, nSomaQuadrados, nI, nVariancia, nDesvio
        
        nMedia := This:calcularMedia(aValores)
        nSomaQuadrados := 0
        
        For nI := 1 To Len(aValores)
            nSomaQuadrados += (aValores[nI] - nMedia) ^ 2
        Next
        
        nVariancia := Iif(Len(aValores) > 1, nSomaQuadrados / (Len(aValores) - 1), 0)
        nDesvio := Sqrt(nVariancia)
        
        Return nDesvio

    /*
     * Interpreta índices de capacidade do processo
     */
    Method interpretarIndicesCapacidade(nCp, nCpk)
        Local cInterpretacao
        
        If nCpk >= 1.67
            cInterpretacao := "Processo muito capaz - Classe Mundial"
        ElseIf nCpk >= 1.33
            cInterpretacao := "Processo adequado - Satisfatório"
        ElseIf nCpk >= 1.0
            cInterpretacao := "Processo mínimo - Necessita melhorias"
        ElseIf nCpk >= 0.67
            cInterpretacao := "Processo inadequado - Ação corretiva urgente"
        Else
            cInterpretacao := "Processo crítico - Revisão completa necessária"
        EndIf
        
        Return cInterpretacao

    // =====================================================================
    // PARTE 5: INTEGRAÇÕES E UTILITÁRIOS DE QUALIDADE
    // =====================================================================

    /*
     * Sincronização com sistemas externos de qualidade
     * Integração bidirecional com LIMS e outros sistemas
     */
    @Post("/qualidade/sincronizar-sistema-externo")
    action sincronizarSistemaExterno(body)
        Local cSistemaExterno, cTipoOperacao, aDadosEnvio, oRetorno, aResultados
        Local cURLEndpoint, cMetodoHTTP, oHeaders, lErro, cErro, nI
        
        cSistemaExterno := AllTrim(body["sistemaExterno"]) // LIMS, ERP_MATRIZ, SISTEMA_TERCEIRO
        cTipoOperacao := AllTrim(body["tipoOperacao"]) // ENVIAR, RECEBER, SINCRONIZAR
        aDadosEnvio := Iif(body["dados"] != Nil, body["dados"], {})
        cURLEndpoint := AllTrim(body["urlEndpoint"])
        cMetodoHTTP := Iif(body["metodoHTTP"] != Nil, AllTrim(body["metodoHTTP"]), "POST")
        oHeaders := Iif(body["headers"] != Nil, body["headers"], {})
        
        lErro := .F.
        cErro := ""
        aResultados := {}
        
        If Empty(cSistemaExterno) .Or. Empty(cTipoOperacao)
            Return { "sucesso" => .F., "erro" => "Sistema externo e tipo de operação são obrigatórios" }
        EndIf
        
        Begin Sequence
            If cTipoOperacao == "ENVIAR"
                // Prepara dados para envio
                aDadosEnvio := This:prepararDadosEnvio(cSistemaExterno, aDadosEnvio)
                
                // Envia dados
                oRetorno := This:enviarDadosSistemaExterno(cURLEndpoint, cMetodoHTTP, aDadosEnvio, oHeaders)
                
                If oRetorno["sucesso"] == .T.
                    aAdd(aResultados, "Envio realizado com sucesso - " + cValToChar(Len(aDadosEnvio)) + " registros")
                Else
                    lErro := .T.
                    cErro := "Erro no envio: " + oRetorno["erro"]
                EndIf
                
            ElseIf cTipoOperacao == "RECEBER"
                // Recebe dados do sistema externo
                oRetorno := This:receberDadosSistemaExterno(cURLEndpoint, cMetodoHTTP, oHeaders)
                
                If oRetorno["sucesso"] == .T.
                    // Processa dados recebidos
                    aResultados := This:processarDadosRecebidos(cSistemaExterno, oRetorno["dados"])
                Else
                    lErro := .T.
                    cErro := "Erro no recebimento: " + oRetorno["erro"]
                EndIf
                
            ElseIf cTipoOperacao == "SINCRONIZAR"
                // Sincronização bidirecional
                // 1. Envia dados locais
                aDadosEnvio := This:obterDadosParaSincronizacao(cSistemaExterno)
                oRetorno := This:enviarDadosSistemaExterno(cURLEndpoint, cMetodoHTTP, aDadosEnvio, oHeaders)
                
                If oRetorno["sucesso"] == .T.
                    aAdd(aResultados, "Envio: " + cValToChar(Len(aDadosEnvio)) + " registros")
                    
                    // 2. Recebe dados externos
                    oRetorno := This:receberDadosSistemaExterno(cURLEndpoint, "GET", oHeaders)
                    
                    If oRetorno["sucesso"] == .T.
                        aResultados := AConcat(aResultados, This:processarDadosRecebidos(cSistemaExterno, oRetorno["dados"]))
                    Else
                        aAdd(aResultados, "Erro no recebimento: " + oRetorno["erro"])
                    EndIf
                Else
                    lErro := .T.
                    cErro := "Erro na sincronização: " + oRetorno["erro"]
                EndIf
            EndIf
            
            // Registra log da operação
            This:registrarLogIntegracao(cSistemaExterno, cTipoOperacao, aResultados, !lErro)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na integração: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("sincronizarSistemaExterno", "SISTEMA", {"sistema" => cSistemaExterno, "operacao" => cTipoOperacao}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "resultados" => aResultados, "total" => Len(aResultados) }

    /*
     * Backup e restore de dados de qualidade
     * Sistema completo de backup com versionamento
     */
    @Post("/qualidade/backup-dados")
    action backupDadosQualidade(body)
        Local cTipoBackup, aTabelasIncluir, cDiretorioDestino, lCompactar, lCriptografar
        Local aArquivosGerados, oBackup, cVersao, nTamanhoTotal, lErro, cErro
        
        cTipoBackup := Iif(body["tipoBackup"] != Nil, AllTrim(body["tipoBackup"]), "COMPLETO") // COMPLETO, INCREMENTAL, DIFERENCIAL
        aTabelasIncluir := Iif(body["tabelas"] != Nil, body["tabelas"], This:obterTabelasQualidade())
        cDiretorioDestino := Iif(body["diretorioDestino"] != Nil, AllTrim(body["diretorioDestino"]), This:obterDiretorioBackupPadrao())
        lCompactar := Iif(body["compactar"] != Nil, body["compactar"], .T.)
        lCriptografar := Iif(body["criptografar"] != Nil, body["criptografar"], .T.)
        
        lErro := .F.
        cErro := ""
        aArquivosGerados := {}
        nTamanhoTotal := 0
        
        Begin Sequence
            // Gera versão do backup
            cVersao := This:gerarVersaoBackup(cTipoBackup)
            
            // Cria diretório se não existir
            This:criarDiretorio(cDiretorioDestino)
            
            // Executa backup para cada tabela
            For nI := 1 To Len(aTabelasIncluir)
                cTabela := aTabelasIncluir[nI]
                
                // Gera arquivo de backup da tabela
                oArquivo := This:executarBackupTabela(cTabela, cDiretorioDestino, cVersao, cTipoBackup)
                
                If oArquivo["sucesso"] == .T.
                    // Compacta se solicitado
                    If lCompactar
                        oArquivo := This:compactarArquivo(oArquivo["nomeArquivo"])
                    EndIf
                    
                    // Criptografa se solicitado
                    If lCriptografar
                        oArquivo := This:criptografarArquivo(oArquivo["nomeArquivo"])
                    EndIf
                    
                    aAdd(aArquivosGerados, oArquivo)
                    nTamanhoTotal += oArquivo["tamanho"]
                Else
                    lErro := .T.
                    cErro := "Erro no backup da tabela " + cTabela + ": " + oArquivo["erro"]
                    Break
                EndIf
            Next
            
            If !lErro
                // Gera arquivo de manifesto
                oManifesto := This:gerarManifestoBackup(cVersao, aArquivosGerados, cTipoBackup)
                
                oBackup := {;
                    "versao" => cVersao,;
                    "tipoBackup" => cTipoBackup,;
                    "dataHoraBackup" => DToS(Date()) + " " + Time(),;
                    "diretorioDestino" => cDiretorioDestino,;
                    "tabelasIncluidas" => aTabelasIncluir,;
                    "arquivosGerados" => aArquivosGerados,;
                    "tamanhoTotal" => nTamanhoTotal,;
                    "compactado" => lCompactar,;
                    "criptografado" => lCriptografar,;
                    "manifesto" => oManifesto["nomeArquivo"];
                }
                
                // Registra backup no histórico
                This:registrarHistoricoBackup(oBackup)
            EndIf
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no backup: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("backupDadosQualidade", "SISTEMA", {"versao" => cVersao, "tipo" => cTipoBackup}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "backup" => oBackup }

    /*
     * Utilitário de limpeza e manutenção de dados de qualidade
     * Remove dados antigos e otimiza performance
     */
    @Post("/qualidade/manutencao-dados")
    action manutencaoDadosQualidade(body)
        Local nDiasRetencao, lLimparLogs, lOtimizarTabelas, lReindexar, lCompactar
        Local aResultados, oEstatisticas, nRegistrosRemovidos, lErro, cErro
        
        nDiasRetencao := Iif(body["diasRetencao"] != Nil, body["diasRetencao"], 730) // 2 anos padrão
        lLimparLogs := Iif(body["limparLogs"] != Nil, body["limparLogs"], .T.)
        lOtimizarTabelas := Iif(body["otimizarTabelas"] != Nil, body["otimizarTabelas"], .T.)
        lReindexar := Iif(body["reindexar"] != Nil, body["reindexar"], .F.)
        lCompactar := Iif(body["compactar"] != Nil, body["compactar"], .F.)
        
        lErro := .F.
        cErro := ""
        aResultados := {}
        nRegistrosRemovidos := 0
        
        Begin Sequence
            // Obtém estatísticas antes da limpeza
            oEstatisticas := This:obterEstatisticasTabelasQualidade()
            aAdd(aResultados, "Estatísticas iniciais coletadas")
            
            If lLimparLogs
                // Remove logs antigos
                nRemovidos := This:limparLogsAntigos(nDiasRetencao)
                nRegistrosRemovidos += nRemovidos
                aAdd(aResultados, "Logs removidos: " + cValToChar(nRemovidos))
            EndIf
            
            // Remove dados antigos de ensaios
            nRemovidos := This:limparEnsaiosAntigos(nDiasRetencao)
            nRegistrosRemovidos += nRemovidos
            aAdd(aResultados, "Ensaios antigos removidos: " + cValToChar(nRemovidos))
            
            // Remove certificados antigos
            nRemovidos := This:limparCertificadosAntigos(nDiasRetencao)
            nRegistrosRemovidos += nRemovidos
            aAdd(aResultados, "Certificados antigos removidos: " + cValToChar(nRemovidos))
            
            If lOtimizarTabelas
                // Otimiza tabelas de qualidade
                aOtimizacao := This:otimizarTabelasQualidade()
                aResultados := AConcat(aResultados, aOtimizacao)
            EndIf
            
            If lReindexar
                // Reconstrói índices
                aReindexacao := This:reindexarTabelasQualidade()
                aResultados := AConcat(aResultados, aReindexacao)
            EndIf
            
            If lCompactar
                // Compacta banco de dados
                oCompactacao := This:compactarBancoDados()
                aAdd(aResultados, "Compactação: " + oCompactacao["resultado"])
            EndIf
            
            // Obtém estatísticas finais
            oEstatisticasFinais := This:obterEstatisticasTabelasQualidade()
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na manutenção: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("manutencaoDadosQualidade", "SISTEMA", {"retencao" => nDiasRetencao, "removidos" => nRegistrosRemovidos}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return {;
            "sucesso" => .T.,;
            "resultados" => aResultados,;
            "registrosRemovidos" => nRegistrosRemovidos,;
            "estatisticasIniciais" => oEstatisticas,;
            "estatisticasFinais" => oEstatisticasFinais;
        }

    /*
     * Configuração avançada de parâmetros do sistema de qualidade
     * Interface para configuração de todos os aspectos do sistema
     */
    @Post("/qualidade/configurar-parametros")
    action configurarParametrosQualidade(body)
        Local oConfiguracao, aParametrosAlterados, cUsuario, lErro, cErro
        
        oConfiguracao := body["configuracao"]
        cUsuario := AllTrim(body["usuario"])
        
        lErro := .F.
        cErro := ""
        aParametrosAlterados := {}
        
        If Empty(oConfiguracao) .Or. Empty(cUsuario)
            Return { "sucesso" => .F., "erro" => "Configuração e usuário são obrigatórios" }
        EndIf
        
        Begin Sequence
            // Valida permissões do usuário
            If !This:validarPermissaoConfiguracao(cUsuario)
                Return { "sucesso" => .F., "erro" => "Usuário sem permissão para alterar configurações" }
            EndIf
            
            // Processa cada categoria de configuração
            If oConfiguracao["alertas"] != Nil
                This:configurarAlertas(oConfiguracao["alertas"])
                aAdd(aParametrosAlterados, "Alertas")
            EndIf
            
            If oConfiguracao["certificados"] != Nil
                This:configurarCertificados(oConfiguracao["certificados"])
                aAdd(aParametrosAlterados, "Certificados")
            EndIf
            
            If oConfiguracao["calibracao"] != Nil
                This:configurarCalibracao(oConfiguracao["calibracao"])
                aAdd(aParametrosAlterados, "Calibração")
            EndIf
            
            If oConfiguracao["relatorios"] != Nil
                This:configurarRelatorios(oConfiguracao["relatorios"])
                aAdd(aParametrosAlterados, "Relatórios")
            EndIf
            
            If oConfiguracao["integracoes"] != Nil
                This:configurarIntegracoes(oConfiguracao["integracoes"])
                aAdd(aParametrosAlterados, "Integrações")
            EndIf
            
            If oConfiguracao["backup"] != Nil
                This:configurarBackup(oConfiguracao["backup"])
                aAdd(aParametrosAlterados, "Backup")
            EndIf
            
            // Registra alterações
            This:registrarAlteracaoConfiguracao(cUsuario, aParametrosAlterados, oConfiguracao)
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro na configuração: " + oErr:Description
        End Sequence
        
        This:registraLogQualidade("configurarParametrosQualidade", cUsuario, {"parametros" => aParametrosAlterados}, !lErro)
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return {;
            "sucesso" => .T.,;
            "parametrosAlterados" => aParametrosAlterados,;
            "totalAlteracoes" => Len(aParametrosAlterados);
        }

    /*
     * Monitor de saúde do sistema de qualidade
     * Verifica integridade e performance do sistema
     */
    @Get("/qualidade/monitorar-saude-sistema")
    action monitorarSaudeSistema(params)
        Local oSaude, aVerificacoes, nPontuacao, cStatus, lErro, cErro
        
        lErro := .F.
        cErro := ""
        aVerificacoes := {}
        nPontuacao := 0
        
        Begin Sequence
            // Verifica conectividade com banco
            aAdd(aVerificacoes, This:verificarConectividadeBanco())
            
            // Verifica integridade das tabelas
            aAdd(aVerificacoes, This:verificarIntegridadeTabelas())
            
            // Verifica performance das consultas
            aAdd(aVerificacoes, This:verificarPerformanceConsultas())
            
            // Verifica espaço em disco
            aAdd(aVerificacoes, This:verificarEspacoDisco())
            
            // Verifica status dos serviços
            aAdd(aVerificacoes, This:verificarStatusServicos())
            
            // Verifica integrações externas
            aAdd(aVerificacoes, This:verificarIntegracoesExternas())
            
            // Verifica backups
            aAdd(aVerificacoes, This:verificarStatusBackups())
            
            // Calcula pontuação geral
            For nI := 1 To Len(aVerificacoes)
                If aVerificacoes[nI]["status"] == "OK"
                    nPontuacao += aVerificacoes[nI]["peso"]
                ElseIf aVerificacoes[nI]["status"] == "ATENCAO"
                    nPontuacao += aVerificacoes[nI]["peso"] * 0.5
                EndIf
            Next
            
            // Define status geral
            If nPontuacao >= 90
                cStatus := "EXCELENTE"
            ElseIf nPontuacao >= 75
                cStatus := "BOM"
            ElseIf nPontuacao >= 60
                cStatus := "ATENCAO"
            Else
                cStatus := "CRITICO"
            EndIf
            
            oSaude := {;
                "dataHoraVerificacao" => DToS(Date()) + " " + Time(),;
                "statusGeral" => cStatus,;
                "pontuacaoGeral" => nPontuacao,;
                "verificacoes" => aVerificacoes,;
                "recomendacoes" => This:gerarRecomendacoesSaude(aVerificacoes);
            }
            
        Recover Using oErr
            lErro := .T.
            cErro := "Erro no monitoramento: " + oErr:Description
        End Sequence
        
        If lErro
            Return { "sucesso" => .F., "erro" => cErro }
        EndIf
        
        Return { "sucesso" => .T., "saudeSistema" => oSaude }

    // =====================================================================
    // MÉTODOS AUXILIARES - PARTE 5
    // =====================================================================
    
    /*
     * Prepara dados para envio a sistema externo
     */
    Method prepararDadosEnvio(cSistemaExterno, aDados)
        Local aDadosPreparados, nI, oItem
        
        aDadosPreparados := {}
        
        For nI := 1 To Len(aDados)
            oItem := aDados[nI]
            
            // Adapta formato conforme sistema externo
            If cSistemaExterno == "LIMS"
                oItem := This:formatarParaLIMS(oItem)
            ElseIf cSistemaExterno == "ERP_MATRIZ"
                oItem := This:formatarParaERPMatriz(oItem)
            EndIf
            
            aAdd(aDadosPreparados, oItem)
        Next
        
        Return aDadosPreparados

    /*
     * Obtém tabelas de qualidade para backup
     */
    Method obterTabelasQualidade()
        Local aTabelas
        
        aTabelas := {;
            "QAD010", "QM0010", "QM1010", "QM9010",;
            "QDH010", "QDO010", "QAB010", "QAC010";
        }
        
        Return aTabelas

    /*
     * Executa backup de uma tabela específica
     */
    Method executarBackupTabela(cTabela, cDiretorio, cVersao, cTipoBackup)
        Local cNomeArquivo, cQuery, oArquivo, nTamanho
        
        cNomeArquivo := cDiretorio + "\" + cTabela + "_" + cVersao + ".sql"
        
        If cTipoBackup == "COMPLETO"
            cQuery := "SELECT * FROM " + cTabela + " WHERE D_E_L_E_T_ = ''"
        ElseIf cTipoBackup == "INCREMENTAL"
            cQuery := "SELECT * FROM " + cTabela + " WHERE D_E_L_E_T_ = '' AND R_E_C_N_O_ > " + This:obterUltimoRecnoBackup(cTabela)
        EndIf
        
        // Executa exportação (implementação específica do banco)
        oArquivo := This:exportarTabelaParaArquivo(cQuery, cNomeArquivo)
        
        Return oArquivo

    /*
     * Verifica conectividade com banco de dados
     */
    Method verificarConectividadeBanco()
        Local oVerificacao, lConectado, nTempoResposta, cErro
        
        lConectado := .F.
        nTempoResposta := 0
        cErro := ""
        
        Begin Sequence
            nInicio := Seconds()
            // Executa query simples para testar conexão
            aDados := This:executarQuery("SELECT COUNT(*) AS QTD FROM SX2010 WHERE X2_CHAVE = 'QAD'")
            nTempoResposta := Seconds() - nInicio
            
            lConectado := !Empty(aDados) .And. aDados[1]["QTD"] > 0
            
        Recover Using oErr
            cErro := oErr:Description
        End Sequence
        
        oVerificacao := {;
            "item" => "Conectividade Banco",;
            "status" => Iif(lConectado, "OK", "ERRO"),;
            "detalhes" => Iif(lConectado, "Tempo: " + cValToChar(nTempoResposta) + "s", cErro),;
            "peso" => 20;
        }
        
        Return oVerificacao

    /*
     * Gera código único para auditoria
     */
    Method gerarCodigoAuditoria(cTipo)
        Local cCodigo
        
        cCodigo := "AUD" + cTipo + DToS(Date()) + StrTran(Time(), ":", "")
        
        Return cCodigo

    /*
     * Gera código único para ação corretiva
     */
    Method gerarCodigoAcaoCorretiva(cTipo)
        Local cCodigo
        
        cCodigo := Iif(cTipo == "CORRETIVA", "AC", "AP") + DToS(Date()) + StrTran(Time(), ":", "")
        
        Return cCodigo

EndClass
